import SteveModel from '@shell/plugins/steve/steve-class';
import { PRODUCT_NAME, PAGE } from '@sbomscanner/types';
import { constructImageName } from '@sbomscanner/utils/image';

export default class VulnerabilityReport extends SteveModel {
  get _availableActions() {
    const out = super._availableActions || [];

    // Remove download actions and View in API, keep edit YAML and clone
    const remove = new Set([
      'download',
      'downloadYaml',
      'downloadyaml',
      'viewYaml',
      'goToViewYaml',
      'viewInApi',
      'showConfiguration',
    ]);

    return out.filter((a) => !a?.action || !remove.has(a.action));
  }

  get listLocation() {
    return { name: `c-cluster-${ PRODUCT_NAME }-${ PAGE.VULNERABILITIES }` };
  }

  get doneOverride() {
    return this.listLocation;
  }

  get parentLocationOverride() {
    return this.listLocation;
  }

  // Get parsed report data
  get reportData() {
    if (!this.report) {
      return null;
    }

    try {
      return typeof this.report === 'string' ? JSON.parse(this.report) : this.report;
    } catch (error) {
      return null;
    }
  }

  // Get vulnerability list from report
  get vulnerabilities() {
    const data = this.reportData;

    if (!data?.results || !Array.isArray(data.results) || data.results.length === 0) {
      return [];
    }

    // Extract vulnerabilities from the nested structure: report.results[0].vulnerabilities
    return data.results[0].vulnerabilities || [];
  }

  // Get severity distribution from report
  get severityDistribution() {
    const vulnerabilities = this.vulnerabilities;
    const distribution = {
      critical: 0, high: 0, medium: 0, low: 0, none: 0
    };

    vulnerabilities.forEach((vuln) => {
      const severity = vuln.severity?.toLowerCase();

      if (Object.prototype.hasOwnProperty.call(distribution, severity)) {
        distribution[severity]++;
      } else {
        distribution.none++;
      }
    });

    return distribution;
  }

  // Get total vulnerability count
  get totalVulnerabilities() {
    const distribution = this.severityDistribution;

    return Object.values(distribution).reduce((sum, count) => sum + count, 0);
  }

  // Get overall severity (highest severity with count > 0)
  get overallSeverity() {
    const severities = ['critical', 'high', 'medium', 'low', 'none'];
    const distribution = this.severityDistribution;

    for (const severity of severities) {
      if (distribution[severity] > 0) {
        return severity;
      }
    }

    return 'none';
  }

  // Get most severe vulnerabilities (top 5 by severity and score)
  get mostSevereVulnerabilities() {
    const vulnerabilities = this.vulnerabilities;

    // Sort by severity (critical > high > medium > low > none) and then by score
    const severityOrder = {
      critical: 5, high: 4, medium: 3, low: 2, none: 1
    };

    return vulnerabilities
      .sort((a, b) => {
        const severityDiff = (severityOrder[b.severity?.toLowerCase()] || 0) - (severityOrder[a.severity?.toLowerCase()] || 0);

        if (severityDiff !== 0) return severityDiff;

        // If same severity, sort by score (higher score first)
        const scoreA = parseFloat(a.cvss?.nvd?.v3score) || 0;
        const scoreB = parseFloat(b.cvss?.nvd?.v3score) || 0;

        return scoreB - scoreA;
      })
      .slice(0, 5);
  }

  // Get associated image
  get associatedImage() {
    if (!this.spec?.image) return null;

    const images = this.$getters['all'](this.$rootGetters['i18n/t']('imageScanner.resources.image'));

    return images.find((image) => image.metadata?.name === this.spec.image ||
      image.spec?.name === this.spec.image
    );
  }

  get imageReference() {
    return constructImageName(this.imageMetadata);
  }
}
