<template>
  <div>
    <!-- Vulnerability Table -->
    <SortableTable
      :key="`table-${isGrouped ? 'grouped' : 'ungrouped'}`"
      :rows="isGrouped ? layerData : safeTableData"
      :headers="isGrouped ? LAYER_BASED_TABLE : VULNERABILITY_DETAILS_TABLE"
      :has-advanced-filtering="false"
      :namespaced="false"
      :row-actions="false"
      :search="false"
      :paging="true"
      :key-field="'id'"
      :sub-expandable="isGrouped"
      :sub-rows="isGrouped"
      :sub-expand-column="isGrouped"
      @selection="onSelectionChange"
    >
      <template #header-left>
        <div class="table-header-actions">
          <button
            class="btn role-primary"
            :disabled="selectedVulnerabilityCount === 0"
            @click="downloadCustomReport"
          >
            <i class="icon icon-download"></i>&nbsp;
            {{ t('imageScanner.images.buttons.downloadCustomReport') }}
          </button>
          <span
            v-if="selectedVulnerabilityCount > 0"
            class="selected-count"
          >
            {{ selectedVulnerabilityCount }} {{ selectedVulnerabilityCount > 1 ? t('imageScanner.imageDetails.selection.vulnerabilities') : t('imageScanner.imageDetails.selection.vulnerability') }}
          </span>
        </div>
      </template>
      <template #header-right>
        <Checkbox
          v-model:value="isGrouped"
          style="margin: auto 0;"
          label-key="imageScanner.imageDetails.groupByLayer"
        />
      </template>
      <template
        v-if="isGrouped"
        #sub-row="{ row, fullColspan }"
      >
        <tr class="sub-row">
          <td :colspan="fullColspan">
            <SortableTable
              class="sub-table"
              :rows="(row.vulnerabilityList || []).filter(vuln => vuln && typeof vuln === 'object' && vuln.id)"
              :headers="VULNERABILITY_DETAILS_TABLE"
              :search="false"
              :row-actions="false"
              :table-actions="false"
              :key-field="'id'"
            />
          </td>
        </tr>
      </template>
    </SortableTable>
  </div>
</template>

<script>
import SortableTable from '@shell/components/SortableTable';
import { Checkbox } from '@components/Form/Checkbox';
import { VULNERABILITY_DETAILS_TABLE, LAYER_BASED_TABLE } from '@sbomscanner/config/table-headers';
import day from 'dayjs';
import { downloadCSV } from '@sbomscanner/utils/report';
import { decodeBase64 } from '@sbomscanner/utils/app';
export default {
  name:       'VulnerabilityTable',
  components: {
    SortableTable,
    Checkbox,
  },
  props: {
    cachedFilteredVulnerabilities: {
      type:    Array,
      default: () => {
        return [];
      },
    },
    imageName: {
      type:    String,
      default: '',
    },
    currentImage: {
      type:    Object,
      default: () => {
        return {};
      },
    },
  },
  data() {
    return {
      layerData:               [],
      selectedVulnerabilities: [],
      isGrouped:               false,
      VULNERABILITY_DETAILS_TABLE,
      LAYER_BASED_TABLE,
    };
  },
  watch: {
    isGrouped(newVal, oldVal) {
      // Clear selections when switching modes
      if (newVal !== oldVal) {
        this.selectedVulnerabilities = [];
        if (newVal) {
          this.layerData = this.vulnerabilitiesByLayer(this.cachedFilteredVulnerabilities, this.currentImage) || [];
        }
      }
    }
  },
  computed: {
    filteredVulnerabilities() {
      // Return cached results to prevent selection issues
      return this.cachedFilteredVulnerabilities;
    },
    // Safe data for SortableTable
    safeTableData() {
      const vulnData = this.filteredVulnerabilities || [];

      return vulnData.filter((item) => item && typeof item === 'object' && item.id);
    },
    selectedVulnerabilityCount() {
      return this.selectedVulnerabilities ? this.selectedVulnerabilities.length : 0;
    },
  },
  methods: {
    async onSelectionChange(selected) {
      // Handle selection changes for both grouped and ungrouped modes
      await this.$nextTick();
      if (this.isGrouped) {
        // When grouped, selected items are layer objects
        // We need to extract all vulnerabilities from selected layers
        const allVulnerabilities = [];

        if (Array.isArray(selected)) {
          selected.forEach((layer) => {
            if (layer && layer.vulnerabilityList && Array.isArray(layer.vulnerabilityList)) {
              allVulnerabilities.push(...layer.vulnerabilityList);
            }
          });
        }
        this.selectedVulnerabilities = allVulnerabilities;
      } else {
        // When not grouped, selected items are individual vulnerabilities
        this.selectedVulnerabilities = Array.isArray(selected) ? selected : [];
      }
    },
    async onSubTableSelectionChange(selected) {
      // Handle selection from sub-tables (individual vulnerabilities within layers)
      await this.$nextTick();

      if (this.isGrouped) {
        // When grouped, we need to merge sub-table selections with layer selections
        // For now, we'll replace the selection with sub-table selections
        // This allows selecting individual vulnerabilities within layers
        this.selectedVulnerabilities = Array.isArray(selected) ? selected : [];
      }
    },
    // Group vulnerabilities by layer (diffID) - following ImageOverview pattern
    vulnerabilitiesByLayer(vulnerabilityReport, currentImage) {
      try {
        // Group vulnerabilities by diffID (layer identifier)
        const layerMap = new Map();

        vulnerabilityReport.forEach((vuln) => {
          const layerId = vuln.diffID || vuln.packagePath || this.t('imageScanner.general.unknown');
          const mapKey = layerId;

          if (layerMap.has(mapKey)) {
            const layer = layerMap.get(mapKey);

            if (layer && layer.vulnerabilityList && Array.isArray(layer.vulnerabilityList)) {
              layer.vulnerabilityList.push(vuln);
              // Count severity
              const severity = vuln.severity?.toLowerCase() || 'none';

              if (layer.severityCounts && layer.severityCounts[severity] !== undefined) {
                layer.severityCounts[severity]++;
              }
              layerMap.set(mapKey, {
                id:                mapKey,
                layerId:           this.decodeLayerId(layer.layerId), // Decode layer ID to show meaningful information
                vulnerabilities:   this.formatVulnerabilityCounts(layer.severityCounts),
                updated:           this.getLayerUpdatedTime(),
                size:              this.getLayerSize(layer.layerId),
                severityCounts:    layer.severityCounts,
                vulnerabilityList: layer.vulnerabilityList,
              });
            }
          } else {
            const severityCounts = {
              critical: 0, high: 0, medium: 0, low: 0, none: 0
            };
            const severity = vuln.severity?.toLowerCase() || 'none';

            if (severityCounts[severity] !== undefined) {
              severityCounts[severity]++;
            }

            layerMap.set(mapKey, {
              id:                mapKey,
              layerId:           this.decodeLayerId(layerId), // Decode layer ID to show meaningful information
              vulnerabilities:   this.formatVulnerabilityCounts(severityCounts),
              updated:           this.getLayerUpdatedTime(),
              size:              this.getLayerSize(layerId),
              severityCounts,
              vulnerabilityList: [vuln]
            });
          }
        });

        currentImage.layers?.forEach((layer) => {
          const mapKey = layer.diffID || layer.digest || null;

          if (mapKey && !layerMap.has(mapKey)) {
            layerMap.set(mapKey, {
              id:              mapKey,
              layerId:         this.decodeLayerId(mapKey),
              vulnerabilities: this.formatVulnerabilityCounts({}),
              updated:         this.getLayerUpdatedTime(),
              size:            this.getLayerSize(mapKey),
              severityCounts:  {
                critical: 0, high: 0, medium: 0, low: 0, none: 0
              },
              vulnerabilityList: []
            });
          }
        });

        // Create severity breakdown and sort

        const result = Array.from(layerMap.values()).map((layer) => {
          const counts = layer.severityCounts;

          layer.vulnerabilities = this.formatVulnerabilityCounts(counts);
          layer.updated = this.getLayerUpdatedTime();
          layer.size = this.getLayerSize(layer.id);

          return layer;
        }).filter((layer) => layer !== null && layer !== undefined).sort((a, b) => {
          if (!a || !b) return 0;

          return (b.vulnerabilityList?.length || 0) - (a.vulnerabilityList?.length || 0);
        });

        return result;
      } catch (error) {
        return [];
      }
    },
    decodeLayerId(layerId) {
      if (!layerId || layerId === this.t('imageScanner.general.unknown')) {
        return 'Unknown Layer';
      }

      // If it's a SHA256 hash, try to decode it or show a truncated version
      if (layerId.startsWith('sha256:')) {
        const hash = layerId.substring(7); // Remove 'sha256:' prefix
        const shortHash = hash.substring(0, 12); // Show first 12 characters

        // Try to get layer information from image data
        if (this.currentImage && this.currentImage.layers) {
          // Look for layer information in the image data
          const layers = this.currentImage.layers;

          if (Array.isArray(layers)) {
            const layerInfo = layers.find((layer) => layer.diffID === layerId ||
              layer.digest === layerId ||
              (layer.command && layer.command.includes(hash.substring(0, 8)))
            );

            if (layerInfo && layerInfo.command) {
              // Return the decoded command
              return decodeBase64(layerInfo.command) || layerInfo.command;
            }
          }
        }

        // Fallback: show truncated hash with layer number
        return `Layer: ${ shortHash }...`;
      }

      // If it's a package path (purl), extract meaningful info
      if (layerId.includes('pkg:')) {
        const parts = layerId.split('@');

        if (parts.length > 1) {
          const packageInfo = parts[0].split('/').pop();
          const version = parts[1].split('?')[0];

          return `${ packageInfo }@${ version }`;
        }
      }

      // Default fallback
      return layerId.length > 50 ? `${ layerId.substring(0, 50) }...` : layerId;
    },

    // Format vulnerability counts for display (returns object for IdentifiedCVEsCell)
    formatVulnerabilityCounts(severityCounts) {
      if (!severityCounts) {
        return {
          critical: 0, high: 0, medium: 0, low: 0, unknown: 0
        };
      }

      return {
        critical: severityCounts.critical || 0,
        high:     severityCounts.high || 0,
        medium:   severityCounts.medium || 0,
        low:      severityCounts.low || 0,
        unknown:  severityCounts.none || 0
      };
    },

    // Get layer updated time
    getLayerUpdatedTime() {
      // Try to get from image metadata
      if (this.currentImage && this.currentImage.metadata) {
        const ts = this.currentImage?.metadata?.creationTimestamp;

        if (!ts) {
          return this.t('imageScanner.general.unknown');
        }

        const date = new Date(ts);

        if (isNaN(date.getTime())) {
          return this.t('imageScanner.general.unknown');
        }

        return `${day(date).format('MMM D, YYYY')} ${day(date).format('h:mm a')}`;
      }

      return this.t('imageScanner.general.unknown');
    },

    // Get layer size
    getLayerSize(layerId) {
      // Since individual layer sizes aren't available in the current data structure,
      // we'll show a placeholder or calculate an estimated size

      // Try to get from image layers data first
      if (this.currentImage && this.currentImage.layers) {
        const layers = this.currentImage.layers;

        if (Array.isArray(layers)) {
          const layerInfo = layers.find((layer) => layer.diffID === layerId ||
            layer.digest === layerId ||
            (layer.diffID && layer.diffID.includes(layerId.substring(0, 12)))
          );

          if (layerInfo && layerInfo.size) {
            // Convert bytes to MB if needed
            if (typeof layerInfo.size === 'number') {
              return `${ (layerInfo.size / 1024 / 1024).toFixed(2) } MB`;
            }

            return layerInfo.size;
          }
        }
      }

      // Return placeholder since individual layer sizes aren't available
      return this.t('imageScanner.general.unknown');
    },

    downloadCustomReport() {
      try {
        if (this.selectedVulnerabilities.length === 0) {
          this.$store.dispatch('growl/error', {
            title:   'Error',
            message: 'No vulnerability report data available for download'
          }, { root: true });

          return;
        }

        // Generate CSV from filtered vulnerability data
        const csvData = this.generateCSVFromFilteredVulnerabilities();

        downloadCSV(csvData, `${ this.imageName }-image-detail-report_${ day(new Date().getTime()).format('MMDDYYYY_HHmmss') }.csv`);

        this.$store.dispatch('growl/success', {
          title:   'Success',
          message: 'Custom report downloaded successfully'
        }, { root: true });
      } catch (error) {
        this.$store.dispatch('growl/error', {
          title:   'Error',
          message: `Failed to download custom report: ${ error.message }`
        }, { root: true });
      }
    },

    generateCSVFromFilteredVulnerabilities() {
      // Use selected vulnerabilities if any are selected, otherwise use all filtered vulnerabilities
      const vulnerabilities = this.selectedVulnerabilities && this.selectedVulnerabilities.length > 0 ? this.selectedVulnerabilities : this.filteredVulnerabilities;

      const headers = [
        'CVE_ID',
        'SCORE',
        'PACKAGE',
        'FIX AVAILABLE',
        'SEVERITY',
        'EXPLOITABILITY',
        'PACKAGE VERSION',
        'PACKAGE PATH',
        'DESCRIPTION',
      ];

      const csvRows = [headers.join(',')];

      vulnerabilities.forEach((vuln) => {
        const row = [
          `"${ vuln.cveId || '' }"`,
          `"${ vuln.score || '' }"`,
          `"${ vuln.package || '' }"`,
          `"${ vuln.fixVersion }"`,
          `"${ vuln.severity || '' }"`,
          `"${ vuln.exploitability || '' }"`,
          `"${ vuln.installedVersion || '' }"`,
          `"${ vuln.packagePath || '' }"`,
          `"${ vuln.description.replace(/"/g, "'").replace(/[\r\n]+/g, ' ') }"`,
        ];

        csvRows.push(row.join(','));
      });

      return csvRows.join('\n');
    },
  },
};
</script>

<style lang="scss" scoped>
.selected-count {
  font-weight: 400;
}

.table-header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
}

.table-top-left {
  display: flex;
  align-items: center;
  gap: 16px;
}
</style>
