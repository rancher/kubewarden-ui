import { shallowMount } from '@vue/test-utils';
import VulnerabilityTable from '../VulnerabilityTable.vue';
import { downloadCSV } from '../../../utils/report';
import { decodeBase64 } from '../../../utils//app';

// Mock external modules
jest.mock('@sbomscanner/utils/report', () => ({ downloadCSV: jest.fn() }));
jest.mock('@sbomscanner/utils/app', () => ({ decodeBase64: jest.fn((input) => `decoded(${input})`) }));
// dayjs must be a callable function (default import). Return object with .format(fmt)
jest.mock('dayjs', () => jest.fn(() => {
  return {
    format: (fmt) => {
      if (fmt === 'MMM D, YYYY') return 'Oct 30, 2025';
      if (fmt === 'h:mm a') return '3:45 pm';
      if (fmt === 'MMDDYYYY_HHmmss') return '10302025_1545';

      return 'FORMATTED';
    }
  };
}));

// Simple stubs for child components used in the template
const SortableTableStub = {
  name:  'SortableTable',
  props: ['rows', 'headers', 'keyField'],
  render(h) {
    return h('div', { class: 'sortable-table-stub' });
  },
};
const CheckboxStub = {
  name:  'Checkbox',
  props: ['value', 'labelKey'],
  render(h) {
    return h('input');
  },
};

describe('VulnerabilityTable.vue (Vue2)', () => {
  let wrapper: any;
  let storeMock: any;

  const sampleVulns = [
    {
      id:               '1',
      cveId:            'CVE-111',
      severity:         'High',
      score:            '9.8',
      package:          'openssl',
      fixVersion:       '1.1.1',
      exploitability:   'available',
      installedVersion: '1.1.0',
      packagePath:      '/usr/lib/openssl',
      description:      'Test vuln 1',
      diffID:           'sha256:abcdef1234567890',
    },
    {
      id:               '1',
      cveId:            'CVE-121',
      severity:         'Medium',
      score:            '7.6',
      package:          'pip',
      fixVersion:       '1.1.1',
      exploitability:   'available',
      installedVersion: '1.1.0',
      packagePath:      '/usr/lib/openssl',
      description:      'Test vuln 1',
      diffID:           'sha256:abcdef1234567890',
    },
    {
      id:               '2',
      cveId:            'CVE-222',
      severity:         'LOW',
      score:            '2.1',
      package:          'nginx',
      fixVersion:       '',
      exploitability:   'available',
      installedVersion: '1.2.3',
      packagePath:      '/usr/bin/nginx',
      description:      'Test vuln 2',
      diffID:           'layer-2',
    },
  ];

  beforeEach(() => {
    jest.clearAllMocks();

    storeMock = { dispatch: jest.fn() };

    wrapper = shallowMount(VulnerabilityTable, {
      stubs: {
        SortableTable: SortableTableStub,
        Checkbox:      CheckboxStub,
      },
      propsData: {
        cachedFilteredVulnerabilities: sampleVulns,
        imageName:                     'test-image',
        currentImage:                  {}, // default, tests override where needed
      },
      global: {
        mocks: {
          $store: storeMock,
          t:      (key) => key, // i18n mock returns key
        },
      }
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('mounts and initializes data properly', () => {
    expect(wrapper.exists()).toBe(true);
    expect(wrapper.vm.isGrouped).toBe(false);
    expect(wrapper.vm.layerData).toEqual([]);
    expect(wrapper.vm.VULNERABILITY_DETAILS_TABLE).toBeDefined();
    expect(wrapper.vm.LAYER_BASED_TABLE).toBeDefined();
  });

  it('computed filteredVulnerabilities returns prop value', () => {
    expect(wrapper.vm.filteredVulnerabilities).toEqual(sampleVulns);
  });

  it('safeTableData filters out invalid entries', async() => {
    wrapper.setProps({ cachedFilteredVulnerabilities: [...sampleVulns, null, 42, {}] });
    await wrapper.vm.$nextTick();
    const safe = wrapper.vm.safeTableData;

    // Only objects with id should remain (2)
    expect(safe).toHaveLength(3);
    expect(safe.every((i) => i && i.id)).toBe(true);
  });

  it('selectedVulnerabilityCount reflects selectedVulnerabilities length', () => {
    wrapper.setData({ selectedVulnerabilities: [sampleVulns[0]] });
    expect(wrapper.vm.selectedVulnerabilityCount).toBe(1);
  });

  describe('watcher: isGrouped', () => {
    it('clears selectedVulnerabilities and calls vulnerabilitiesByLayer when toggled on', async() => {
      const spy = jest.spyOn(wrapper.vm, 'vulnerabilitiesByLayer');

      // set isGrouped true
      wrapper.setData({ isGrouped: true });
      await wrapper.vm.$nextTick();
      expect(wrapper.vm.selectedVulnerabilities).toEqual([]);
      expect(spy).toHaveBeenCalledWith(sampleVulns, wrapper.vm.currentImage);
    });
    it('clears selectedVulnerabilities and calls vulnerabilitiesByLayer when toggled on - cachedFilteredVulnerabilities, currentImage are undefined', async() => {
      await wrapper.setProps({ cachedFilteredVulnerabilities: undefined });
      await wrapper.setProps({ currentImage: undefined });
      const spy = jest.spyOn(wrapper.vm, 'vulnerabilitiesByLayer');

      // set isGrouped true
      wrapper.setData({ isGrouped: true });
      await wrapper.vm.$nextTick();
      expect(wrapper.vm.selectedVulnerabilities).toEqual([]);
      expect(spy).toHaveBeenCalledWith([], wrapper.vm.currentImage);
    });
  });

  describe('onSelectionChange', () => {
    it('sets selectedVulnerabilities to selection when ungrouped', async() => {
      await wrapper.vm.onSelectionChange([sampleVulns[0]]);
      expect(wrapper.vm.selectedVulnerabilities).toEqual([sampleVulns[0]]);
    });

    it('when grouped, flattens selected layers into vulnerabilities', async() => {
      wrapper.setData({ isGrouped: true });
      const layerSelection = [{ vulnerabilityList: [sampleVulns[0], sampleVulns[1]] }];

      await wrapper.vm.onSelectionChange(layerSelection);
      expect(wrapper.vm.selectedVulnerabilities).toEqual([sampleVulns[0], sampleVulns[1]]);
    });

    it('handles internal error by setting selectedVulnerabilities to []', async() => {
      // Force an error to be thrown inside the try block by mocking Array.isArray to throw

      jest.spyOn(Array, 'isArray').mockImplementation(() => false );

      await wrapper.vm.onSelectionChange([sampleVulns[0]]);
      expect(wrapper.vm.selectedVulnerabilities).toEqual([]);

      // restore
      Array.isArray.mockRestore();
      // sanity check: restore working
      expect(Array.isArray([1,2])).toBe(true);
    });
  });

  describe('onSubTableSelectionChange', () => {
    it('replaces selectedVulnerabilities with sub-table selections when grouped', async() => {
      wrapper.setData({ isGrouped: true });
      await wrapper.vm.onSubTableSelectionChange([sampleVulns[1]]);
      expect(wrapper.vm.selectedVulnerabilities).toEqual([sampleVulns[1]]);
    });
  });

  describe('vulnerabilitiesByLayer(currentImage) grouping', () => {
    it('groups vulnerabilities by diffID and includes layers from currentImage', () => {
      const currentImage = {
        layers: [
          {
            diffID: 'sha256:abcdef1234567890', command: 'Y21k', size: 2048
          },
          {
            diffID: 'layer-2', digest: 'layer-2-digest', size: 4096
          },
          { diffID: 'orphan-layer' },
        ],
        metadata:      { creationTimestamp: new Date().toISOString() },
        imageMetadata: { size: 1048576 },
      };

      // Mount a fresh wrapper with currentImage
      const w = shallowMount(VulnerabilityTable, {
        stubs:     { SortableTable: SortableTableStub, Checkbox: CheckboxStub },
        mocks:     { $store: storeMock, t: (k) => k },
        propsData: {
          cachedFilteredVulnerabilities: sampleVulns,
          imageName:                     'img',
          currentImage,
        },
      });

      const layers = w.vm.vulnerabilitiesByLayer(sampleVulns, currentImage);
      // We expect layers to include at least the map keys for sample diffIDs and orphan-layer
      const ids = layers.map((l) => l.id);

      expect(ids).toEqual(expect.arrayContaining(['sha256:abcdef1234567890', 'layer-2', 'orphan-layer']));
      // vulnerabilityList lengths should match grouped items
      const shaLayer = layers.find((l) => l.id === 'sha256:abcdef1234567890');

      expect(shaLayer.vulnerabilityList.length).toBeGreaterThanOrEqual(1);
    });

    it('returns [] when invalid vulnerabilityReport provided', () => {
      const res = wrapper.vm.vulnerabilitiesByLayer(null, {});

      expect(res).toEqual([]);
    });
  });

  describe('decodeLayerId', () => {
    it('returns Unknown Layer for falsy/unknown id', () => {
      expect(wrapper.vm.decodeLayerId('')).toBe('Unknown Layer');
      expect(wrapper.vm.decodeLayerId(undefined)).toBe('Unknown Layer');
    });

    it('decodes sha256 id using currentImage layers command via decodeBase64', async() => {
      const currentImage = {
        layers: [
          { diffID: 'sha256:abcdef1234567890', command: 'Y21k' },
        ],
      };

      await wrapper.setProps({ currentImage });
      const res = wrapper.vm.decodeLayerId('sha256:abcdef1234567890');

      expect(decodeBase64).toHaveBeenCalledWith('Y21k');
      expect(res).toContain('decoded(');
    });

    it('decodes sha256 id using currentImage layers command via decodeBase64 - currentImage.layerId does not match diffId in vulnerabilities report', async() => {
      const currentImage = {
        layers: [
          { diffID: 'sha256:abcdef1234567890', command: 'sha256:abcdef1234567890' },
        ],
      };

      await wrapper.setProps({ currentImage });
      const res = wrapper.vm.decodeLayerId('sha256:abcdef123456789');

      expect(decodeBase64).not.toHaveBeenCalledWith('abcdef1234567890');
      expect(res).toContain('decoded(');
    });

    it('parses pkg: purl and returns package@version', () => {
      const res = wrapper.vm.decodeLayerId('pkg:npm/vue@2.6.14');

      expect(res).toBe('vue@2.6.14');
    });

    it('truncates long ids', () => {
      const long = 'a'.repeat(60);

      expect(wrapper.vm.decodeLayerId(long).endsWith('...')).toBe(true);
    });
  });

  describe('formatVulnerabilityCounts', () => {
    it('maps counts and maps none to unknown', () => {
      const out = wrapper.vm.formatVulnerabilityCounts({
        critical: 1, high: 2, medium: 3, low: 4, none: 5
      });

      expect(out).toEqual({
        critical: 1, high: 2, medium: 3, low: 4, unknown: 5
      });
    });

    it('returns zeros when undefined passed', () => {
      const out = wrapper.vm.formatVulnerabilityCounts(null);

      expect(out.critical).toBe(0);
      expect(out.unknown).toBe(0);
    });
  });

  describe('getLayerUpdatedTime', () => {
    it('returns formatted string when currentImage.metadata exists', async() => {
      const now = new Date().toISOString();

      await wrapper.setProps({ currentImage: { metadata: { creationTimestamp: now } } });
      const res = wrapper.vm.getLayerUpdatedTime('anything');

      expect(res).toContain('Oct 30, 2025 3:45 pm');
    });

    it('returns i18n unknown when no metadata', async() => {
      await wrapper.setProps({ currentImage: {} });
      const res = wrapper.vm.getLayerUpdatedTime('id');

      expect(res).toBe(wrapper.vm.t('imageScanner.general.unknown'));
    });
  });

  describe('getLayerSize', () => {
    it('returns MB if layer.size numeric present', async() => {
      await wrapper.setProps({ currentImage: { layers: [{ diffID: 'layer-2', size: 1048576 }] } });
      const res = wrapper.vm.getLayerSize('layer-2');

      expect(res).toContain('MB');
    });

    it('returns MB if layer.size numeric present - size is not number', async() => {
      await wrapper.setProps({ currentImage: { layers: [{ diffID: 'layer-2', size: '104MB' }] } });
      const res = wrapper.vm.getLayerSize('layer-2');

      expect(res).toContain('104MB');
    });

    it('falls back to i18n unknown when nothing matches', () => {
      wrapper.setProps({ currentImage: {} });
      const res = wrapper.vm.getLayerSize('no-match');

      expect(res).toBe(wrapper.vm.t('imageScanner.general.unknown'));
    });
  });

  describe('downloadCustomReport', () => {
    it('generates CSV and calls downloadCSV and error growl when selectedVulnerabilities empty (per current code logic)', () => {
      // Note: the component uses `if (!this.selectedVulnerabilities.length === 0)` which is a bug; with empty selection it proceeds to generate CSV.
      wrapper.setData({ selectedVulnerabilities: [] });
      wrapper.vm.downloadCustomReport();
      expect(downloadCSV).not.toHaveBeenCalled();
      expect(storeMock.dispatch).toHaveBeenCalledWith('growl/error', expect.objectContaining({ title: 'Error' }), { root: true });
    });

    it('handles generateCSV errors by dispatching growl error', () => {
      // Force generateCSVFromFilteredVulnerabilities to throw
      jest.spyOn(wrapper.vm, 'generateCSVFromFilteredVulnerabilities').mockImplementation(() => {
        throw new Error('boom');
      });
      wrapper.setData({ selectedVulnerabilities: [sampleVulns[0]] });
      wrapper.vm.downloadCustomReport();
      expect(storeMock.dispatch).toHaveBeenCalledWith('growl/error', expect.objectContaining({ title: 'Error' }), { root: true });
      // restore the mocked method
      wrapper.vm.generateCSVFromFilteredVulnerabilities.mockRestore && wrapper.vm.generateCSVFromFilteredVulnerabilities.mockRestore();
    });
  });

  describe('generateCSVFromFilteredVulnerabilities', () => {
    it('uses selectedVulnerabilities when present to create CSV', () => {
      wrapper.setData({ selectedVulnerabilities: [sampleVulns[0]] });
      const csv = wrapper.vm.generateCSVFromFilteredVulnerabilities();

      expect(csv).toContain('CVE_ID');
      expect(csv).toContain('CVE-111');
      expect(csv.split('\n').length).toBeGreaterThan(1);
    });

    it('falls back to filteredVulnerabilities when selection empty', () => {
      wrapper.setData({ selectedVulnerabilities: [] });
      const csv = wrapper.vm.generateCSVFromFilteredVulnerabilities();

      // Should contain both CVE rows for sampleVulns
      expect(csv).toContain('CVE-111');
      expect(csv).toContain('CVE-222');
    });

    it('escapes double quotes and newlines in description', () => {
      sampleVulns[0].description = 'desc with "quotes" and \n new line';
      const vuln = { ...sampleVulns[0] };

      wrapper.setProps({ cachedFilteredVulnerabilities: [vuln] });
      wrapper.setData({ selectedVulnerabilities: [] });
      const csv = wrapper.vm.generateCSVFromFilteredVulnerabilities();

      expect(csv).not.toContain('"quotes"');
      expect(csv).toContain('\'quotes\'');
      expect(csv).toContain('new line');
    });
  });
});
