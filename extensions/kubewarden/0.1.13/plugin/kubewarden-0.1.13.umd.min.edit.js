(("undefined"!==typeof self?self:this)["webpackJsonpkubewarden_0_1_13"]=("undefined"!==typeof self?self:this)["webpackJsonpkubewarden_0_1_13"]||[]).push([[2,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27],{"00d8":function(e,t){const a=[{questions:[{default:[],description:"This policy works by defining a whitelist of allowed AppArmor profiles. Pods are then inspected at creation and update time, to ensure only approved profiles are used. When no AppArmor profile is defined, Kubernetes will leave the final choice to the underlying container runtime. This will result in using the default AppArmor profile provided by Container Runtime. Because of that, the default behaviour of this policy is to accept workloads that do not have an AppArmor profile specified.",tooltip:"Provide a list of allowed AppArmor profiles",group:"Settings",label:"Allowed profiles",required:!1,type:"array[",variable:"allowed_profiles"}]}];e.exports=a.length<=1?a[0]:a},"016f":function(e,t,a){"use strict";a.r(t);var s=function(){var e=this,t=e.$createElement,a=e._self._c||t;return e.isCreate?a("Create",{attrs:{value:e.value,mode:e.mode}}):a("CruResource",{attrs:{resource:e.value,mode:e.realMode,errors:e.errors},on:{finish:e.finish}},[a("Config",{attrs:{value:e.value,mode:e.mode}})],1)},i=[],o=a("da25"),r=a("305c"),n=a("fd5f"),l=a("90cd"),u=function(){var e=this,t=e.$createElement,a=e._self._c||t;return e.$fetchState.pending?a("Loading",{attrs:{mode:"relative"}}):a("Values",{attrs:{value:e.value,"chart-values":e.chartValues,"yaml-values":e.yamlValues,mode:e.mode}})},p=[],c=a("c5e6"),d=a("15ca"),h=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",[a("div",{staticClass:"scroll__container"},[a("div",{staticClass:"scroll__content"},[a("Tabbed",{ref:"tabs",staticClass:"step__values__content",attrs:{"side-tabs":!0},on:{changed:function(t){return e.tabChanged(t)}}},[a(e.valuesComponent,{tag:"component",attrs:{mode:e.mode},model:{value:e.chartValues,callback:function(t){e.chartValues=t},expression:"chartValues"}})],1)],1)])])},f=[],m=a("0cb2"),b={name:"Values",props:{mode:{type:String,default:o["u"]},chartValues:{type:Object,required:!0},value:{type:Object,required:!0}},components:{Tabbed:m["a"]},async fetch(){try{await this.loadValuesComponent()}catch(e){console.error("Error loading values component: "+e)}},data(){return{showQuestions:!0,showValuesComponent:!1,valuesComponent:null}},computed:{isCreate(){return this.mode===o["u"]}},methods:{async loadValuesComponent(){this.value.haveComponent("kubewarden/policy-server")&&(this.valuesComponent=this.value.importComponent("kubewarden/policy-server"),await this.valuesComponent(),this.showValuesComponent=!0)},tabChanged(){window.scrollTop=0}}},g=b,v=(a("8766"),a("d802")),y=Object(v["a"])(g,h,f,!1,null,"56b7c1bc",null),w=y.exports,_={name:"Config",props:{mode:{type:String,default:o["C"]},value:{type:Object,required:!0}},components:{Loading:d["a"],Values:w},fetch(){this.value&&(this.chartValues={questions:this.value},this.yamlValues=Object(c["c"])(this.value))},data(){return{chartValues:null,yamlValues:null}}},x=_,S=Object(v["a"])(x,u,p,!1,null,null,null),k=S.exports,V=function(){var e=this,t=e.$createElement,a=e._self._c||t;return e.$fetchState.pending?a("Loading",{attrs:{mode:"relative"}}):a("CruResource",{attrs:{resource:e.value,mode:e.realMode,"done-route":e.doneRoute,errors:e.errors,"generate-yaml":e.generateYaml},on:{finish:e.finish,error:e.clearErrors}},[a("Values",{attrs:{value:e.value,"chart-values":e.chartValues,mode:e.mode}})],1)},A=[],R=a("736a"),C=a.n(R),O=a("1fcb"),q=a.n(O),M=a("907c"),j=a("e24b"),P=a("6f75"),T={name:"Create",props:{mode:{type:String,default:o["u"]},value:{type:Object,required:!0}},components:{Loading:d["a"],Values:w,CruResource:n["a"]},mixins:[r["a"]],fetch(){var e,t,a,s,i,o;this.errors=[];const r=C()(JSON.parse(JSON.stringify(P)));this.chartValues={questions:r},this.value.apiVersion=`${null===(e=this.schema)||void 0===e||null===(t=e.attributes)||void 0===t?void 0:t.group}.${null===(a=this.schema)||void 0===a||null===(s=a.attributes)||void 0===s?void 0:s.version}`,this.value.kind=null===(i=this.schema)||void 0===i||null===(o=i.attributes)||void 0===o?void 0:o.kind},data(){return{errors:null,chartValues:null}},methods:{clearErrors(){this.errors=[]},async finish(e){try{var t;q()(this.value,null===(t=this.chartValues)||void 0===t?void 0:t.questions),await this.save(e)}catch(a){this.errors.push(a)}},generateYaml(){var e;const t=this.$store.getters["currentStore"](this.value),a=this.$store.getters[t+"/all"](M["y"]),s=null!==(e=this.chartValues)&&void 0!==e&&e.questions?Object(j["e"])(this.chartValues.questions):this.value,i=Object(c["b"])(a,this.value.type,s);return i}}},N=T,D=Object(v["a"])(N,V,A,!1,null,null,null),I=D.exports,E={components:{CruResource:n["a"],Config:k,Create:I},mixins:[r["a"]],props:{mode:{type:String,default:o["w"]},realMode:{type:String,default:o["w"]},value:{type:Object,required:!0}},async fetch(){this.errors=[],await this.$store.getters["cluster/schemaFor"](l["e"].POLICY_SERVER)},data(){return{errors:null}},computed:{isCreate(){return this.realMode===o["u"]}},methods:{async finish(e){try{await this.save(e)}catch(t){this.errors.push(t)}}}},L=E,G=Object(v["a"])(L,s,i,!1,null,null,null);t["default"]=G.exports},"0398":function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"disallow-service-nodeport"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/disallow-service-nodeport:v0.1.2","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false}}')},"086c":function(e,t){const a=[{questions:[{default:null,description:"Replacement for the Kubernetes Pod Security Policy that controls the usage of volumes in pods. The policy takes the list of the allowed volume types using the allowedTypes setting. The special value * can be used to allow all kind of volumes.",group:"Settings",required:!1,hide_input:!0,type:"string",variable:"description"},{default:[],description:"",tooltip:"A list of the allowed volume types. Note: no other value can be specified together with *. For example, allowedTypes: ['*', 'configMap'] is not a valid configuration setting.",group:"Settings",label:"Allowed types",required:!1,type:"array[",variable:"allowedTypes"}]}];e.exports=a.length<=1?a[0]:a},"0988":function(e,t){const a=[{questions:[{default:null,description:"This policy validates which sysctls can get set in pods by specifying lists of sysctls or sysctl patterns to be allowed or forbidden. You can then modify the securityContext of Pods to make use of the Sysctls as permitted by this policy.",group:"Settings",label:"Description",required:!1,hide_input:!0,type:"string",variable:"description"},{default:[],description:"A list of plain sysctl names or sysctl patterns (which end with *) to be forbidden. You can forbid a combination of safe and unsafe sysctls in the list. To forbid setting any sysctls, use * on its own.",group:"Settings",label:"Forbidden sysctls",required:!1,type:"array[",variable:"forbiddenSysctls"},{default:[],description:"A list of plain sysctl names that can be used in Pods. * cannot be used. Has precedence over forbiddenSysctls.",group:"Settings",label:"Allowed unsafe sysctls",required:!1,type:"array[",variable:"allowedUnsafeSysctls"}]}];e.exports=a.length<=1?a[0]:a},"0e27":function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"selinux-psp"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/selinux-psp:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{"MustRunAs":[{}],"RunAsAny":false}}}')},1:function(e,t){},1041:function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"safe-labels"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/safe-labels:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{"denied_labels":[""],"mandatory_labels":[""],"constrained_labels":[{}]}}}')},"13c1":function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"disallow-service-loadbalancer"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/disallow-service-loadbalancer:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false}}')},1912:function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"hostpaths-psp"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/hostpaths-psp:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{"allowedHostPaths":[{"pathPrefix":"","readOnly":false}]}}}')},"1b4b":function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"capabilities-psp"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/capabilities-psp:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{"allowed_capabilities":[""],"required_drop_capabilities":[""],"default_add_capabilities":[""]}}}')},"1dc0":function(e,t,a){var s=a("c44b");s.__esModule&&(s=s.default),"string"===typeof s&&(s=[[e.i,s,""]]),s.locals&&(e.exports=s.locals);var i=a("0ed3").default;i("0e68c201",s,!0,{sourceMap:!1,shadowMode:!1})},2:function(e,t){},"2b56":function(e,t){const a=[{questions:[{default:null,description:"This policy validates Sigstore signatures for containers, init container and ephemeral container that match the name provided in the image settings field. It will reject the Pod if any validation fails. If all signature validation pass or there is no container that matches the image name, the Pod will be accepted.",group:"Settings",required:!1,hide_input:!0,type:"string",variable:"description"},{default:"PublicKey",description:"The policy takes a list of signatures. A signature can be of two types: public key or keyless. Each signature has an image field which will be used to select the matching containers in the pod that will be evaluated. image supports wildcard. For example, ghcr.io/kubewarden/* will match all images from the kubewarden ghcr repo.",group:"Settings",label:"Signature Type",options:["PublicKey","Keyless"],required:!1,type:"enum",variable:"rule"},{default:[],description:"",group:"Settings",label:"Public key signature",show_if:"rule=PublicKey",hide_input:!0,type:"map[",variable:"signatures",subquestions:[{default:"",group:"Settings",label:"Image",show_if:"rule=PublicKey",type:"string",variable:"signatures.image"},{default:[""],group:"Settings",label:"Public keys",show_if:"rule=PublicKey",type:"array[",variable:"signatures.pubKeys"},{default:[],group:"Settings",label:"Annotations",show_if:"rule=PublicKey",type:"map[",variable:"signatures.annotations"}]},{default:[],group:"Settings",label:"Keyless signature",show_if:"rule=Keyless",hide_input:!0,type:"map[",variable:"signatures",subquestions:[{default:"",group:"Settings",label:"Image",show_if:"rule=Keyless",type:"string",variable:"signatures.image"},{default:[],group:"Settings",label:"Keyless",hide_input:!0,show_if:"rule=Keyless",type:"map[",variable:"signatures.keyless",subquestions:[{default:"",group:"Settings",label:"Issuer",show_if:"rule=Keyless",type:"string",variable:"signatures.keyless.issuer"},{default:"",group:"Settings",label:"Subject",show_if:"rule=Keyless",type:"string",variable:"signatures.keyless.subject"}]},{default:[],group:"Settings",label:"Annotations",show_if:"rule=Keyless",type:"map[",variable:"signatures.annotations"}]},{default:!0,tooltip:"This policy also mutates matching images to add the image digest, therefore the version of the deployed image can't change. This mutation can be disabled by setting modifyImagesWithDigest to false.",group:"Settings",label:"modifyImagesWithDigest",required:!1,title:"Modify images with digest",type:"boolean",variable:"modifyImagesWithDigest"}]}];e.exports=a.length<=1?a[0]:a},"2d7c":function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"apparmor-psp"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/apparmor-psp:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{"allowed_profiles":[""]}}}')},"351d":function(e,t){const a=[{questions:[{default:null,description:"This policy validates the labels of generic Kubernetes objects. It rejects all the resources that use one or more labels on the deny list. It also allows you to put constraints on specific labels. The constraints are expressed as regular expression. It will also allow you to require specific labels to be part of the resource.",group:"Settings",label:"Description",required:!1,hide_input:!0,type:"map",variable:"description"},{default:[],description:"A list of labels that cannot be used",group:"Settings",label:"Denied labels",required:!1,type:"array[",variable:"denied_labels"},{default:[],description:"A list of labels that must be defined",group:"Settings",label:"Mandatory labels",required:!1,type:"array[",variable:"mandatory_labels"},{default:[],tooltip:"Annotations that are validated with user-defined RegExp",group:"Settings",label:"Constrained labels",target:!0,type:"map[",variable:"constrained_labels"}]}];e.exports=a.length<=1?a[0]:a},"360f":function(e,t,a){var s={"./allow-privilege-escalation-psp.json":"7ed5","./allowed-fsgroups-psp.json":"bb31","./allowed-proc-mount-types-psp.json":"9391","./apparmor-psp.json":"2d7c","./capabilities-psp.json":"1b4b","./defaultPolicy.json":"9450","./deprecated-api-versions.json":"aa16","./disallow-service-loadbalancer.json":"13c1","./disallow-service-nodeport.json":"0398","./echo.json":"85d3","./env-variable-secrets-scanner.json":"7cb8","./environment-variable-policy.json":"c8f2","./flexvolume-drivers-psp.json":"866c","./host-namespaces-psp.json":"dbe7","./hostpaths-psp.json":"1912","./ingress-policy.json":"8501","./pod-privileged-policy.json":"56c0","./pod-runtime.json":"a779","./readonly-root-filesystem-psp.json":"b063","./safe-annotations.json":"cf89","./safe-labels.json":"1041","./seccomp-psp.json":"b275","./selinux-psp.json":"0e27","./sysctl-psp.json":"c9dd","./trusted-repos.json":"94f8","./user-group-psp.json":"4f8a","./verify-image-signatures.json":"57a2","./volumemounts.json":"4773","./volumes-psp.json":"d1d7"};function i(e){var t=o(e);return a(t)}function o(e){if(!a.o(s,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return s[e]}i.keys=function(){return Object.keys(s)},i.resolve=o,e.exports=i,i.id="360f"},"3fa6":function(e,t){const a=[{questions:[{default:[""],description:"Provides a list of capabilities that are allowed to be added to a container",tooltip:"Specified as the capability name in ALL_CAPS. (e.g. `CHOWN`, `KILL`)",group:"Settings",label:"Allowed capabilities",required:!1,type:"array[",variable:"allowed_capabilities"},{default:[""],description:"The capabilities which must be dropped from containers.",tooltip:"Specified as the capability name in ALL_CAPS. (e.g. `NET_ADMIN`)",group:"Settings",label:"Required drop capabilities",required:!1,type:"array[",variable:"required_drop_capabilities"},{default:[""],description:"The capabilities which are added to containers by default, in addition to the runtime defaults.",tooltip:"Specified as the capability name in ALL_CAPS. (e.g. `CHOWN`)",group:"Settings",label:"Default add capabilities",required:!1,type:"array[",variable:"default_add_capabilities"}]}];e.exports=a.length<=1?a[0]:a},"437c":function(e,t){const a=[{questions:[{default:!0,description:"This policy works by defining what proc mount types are allowed in containers. They can be empty (defaulted by Kubernetes), `Default` or `Unmasked`. This policy protects against pods that contain at least one container with the `Unmasked` proc mount type, that can potentially expose host information to the container.",tooltip:"Allows the containers, init containers, or ephemeral containers within a pod to set `.spec.securityContext.procMount` to Unmasked. Otherwise, the pod or the ephemeral request subresource request will be rejected.",group:"Settings",label:"Allow unmasked proc mount type",required:!1,type:"boolean",variable:"allow_unmasked_proc_mount_type"}]}];e.exports=a.length<=1?a[0]:a},4773:function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"volumeMounts"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/volumemounts:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{"reject":"","volumeMountsNames":[""]}}}')},"4e08":function(e,t,a){"use strict";a.r(t);var s=function(){var e=this,t=e.$createElement,a=e._self._c||t;return e.isCreate?a("Create",{attrs:{value:e.value,mode:e.mode}}):a("CruResource",{attrs:{resource:e.value,mode:e.realMode},on:{finish:e.finish}},[a("Config",{attrs:{value:e.value,mode:e.mode}})],1)},i=[],o=a("da25"),r=a("42b0"),n=a("305c"),l=a("fd5f"),u=a("edaa"),p=a("ad18"),c={name:"AdmissionPolicy",props:{value:{type:Object,required:!0},mode:{type:String,default:o["w"]},realMode:{type:String,default:o["w"]}},components:{CruResource:l["a"],Config:u["a"],Create:p["a"]},mixins:[r["a"],n["a"]],async fetch(){await this.fetchChart()},provide(){return{chartType:this.value.type}},computed:{isCreate(){return this.realMode===o["u"]}},methods:{async finish(e){try{await this.save(e)}catch(t){this.errors.push(t)}}}},d=c,h=a("d802"),f=Object(h["a"])(d,s,i,!1,null,null,null);t["default"]=f.exports},"4f11":function(e,t){const a=[{questions:[{default:null,description:"This policy provides a replacement for the Pod Security Policy that deals with seccomp profiles. Prior to Kubernetes 1.19, seccomp profiles could be defined only via Pod annotations. Starting from Kubernetes 1.19 the seccomp profiles can be managed via the securityContext field of Pods and Containers. Note: the seccomp annotations are deprecated and will be dropped starting from Kubernetes 1.25.",group:"Settings",label:"Description",required:!1,hide_input:!0,type:"map",variable:"description"},{default:[],tooltip:"Define the accecpted profile values for the annotations container.seccomp.security.alpha.kubernetes.io/<container> and seccomp.security.alpha.kubernetes.io/pod.",group:"Settings",label:"Allowed profiles",required:!1,type:"array[",variable:"allowed_profiles"},{default:[],tooltip:"Define the allowed values to be set in the seccomp type in the security context of a container or of the Pod.",group:"Settings",label:"Profile types",required:!1,type:"array[",variable:"profile_types"},{default:[],tooltip:"Define the allowed localhost profiles. This is used only when the 'Localhost' type is allowed inside of the security context.",group:"Settings",label:"Localhost profiles",required:!1,type:"array[",variable:"localhost_profiles"}]}];e.exports=a.length<=1?a[0]:a},"4f8a":function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"user-group-psp"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/user-group-psp:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{"run_as_user":{"rule":"","overwrite":false,"ranges":[{"min":0,"max":0}]},"run_as_group":{"rule":"","overwrite":false,"ranges":[{"min":0,"max":0}]},"supplemental_groups":{"rule":"","overwrite":false,"ranges":[{"min":0,"max":0}]}}}}')},"54b6":function(e,t){const a=[{questions:[{default:!1,description:"This policy allows you to restrict ingress resources.",tooltip:"Whether the spec for ingress resources has to include a TLS attribute that includes all hosts defined in the .spec.rules attribute of the ingress resource.",group:"Settings",label:"Require TLS",required:!1,type:"boolean",variable:"requireTLS"},{default:[],description:"A list of allowed ports inside `.spec.rules.paths.backend.service.port`. If this array contains at least one port, any other port will be rejected.",group:"Settings",label:"Allow ports",required:!1,type:"array[",variable:"allowPorts"},{default:[],description:"A list of denied ports inside `.spec.rules.paths.backend.service.port`. If any port matches a port on this array, the ingress resource will be rejected, otherwise it will be accepted.",group:"Settings",label:"Deny ports",required:!1,type:"array[",variable:"denyPorts"}]}];e.exports=a.length<=1?a[0]:a},"56c0":function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"pod-privileged-policy"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/pod-privileged:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{}}}')},"57a2":function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"verify-image-signatures"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/verify-image-signatures:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{"modifyImagesWithDigest":true,"signatures":[{"image":"","pubKeys":[""],"annotations":[{}]},{"image":"","keyless":[{"issuer":"","subject":""}],"annotations":[{}]}]}}}')},"5adc":function(e,t){const a=[{questions:[{default:[],description:"This policy is a replacement for the Kubernetes Pod Security Policy that controls the usage of `hostPath` volumes. The policy inspects both the containers and the init containers that are using `hostPath` volumes. `allowedHostPaths` is a list of host paths that are allowed to be used by hostPath volumes. An empty `allowedHostPaths` list means there is no restriction on host paths used. Each entry of `allowedHostPaths` must have: a `pathPrefix` field, which allows hostPath volumes to mount a path that begins with an allowed prefix, and a `readOnly` field indicating it must be mounted read-only.",tooltip:"A list of host paths that are allowed to be used by hostPath volumes.",group:"Settings",label:"Allow host path",hide_input:!0,type:"map[",variable:"allowedHostPaths",subquestions:[{default:"",description:"Allows hostPath volumes to mount a path that begins with an allowed prefix.",group:"Settings",label:"Path prefix",type:"string",variable:"allowedHostPaths.pathPrefix"},{default:!1,tooltip:"Indicates if the volume must be mounted read-only.",group:"Settings",label:"Read only",type:"boolean",variable:"allowedHostPaths.readOnly"}]}]}];e.exports=a.length<=1?a[0]:a},"636e":function(e,t){const a=[{questions:[{default:[],description:"This policy provides a list of allowed Flex Volume drivers. If the pod to be evaluated has a different driver on any `flexVolume` volume, it will be rejected.",tooltip:"The `Key` needs to be `driver`, then provide a flex volume driver as the `Value`. (e.g. `driver: example/lvm`)",group:"Settings",label:"Allowed flex volumes",type:"map[",variable:"allowed_flex_volumes"}]}];e.exports=a.length<=1?a[0]:a},"6e4c":function(e,t,a){var s=a("8309");s.__esModule&&(s=s.default),"string"===typeof s&&(s=[[e.i,s,""]]),s.locals&&(e.exports=s.locals);var i=a("0ed3").default;i("71dc5b58",s,!0,{sourceMap:!1,shadowMode:!1})},"6f75":function(e){e.exports=JSON.parse('{"apiVersion":"policies.kubewarden.io/v1alpha2","kind":"PolicyServer","metadata":{"annotations":{},"labels":{}},"spec":{"annotations":{},"env":[{"name":"KUBEWARDEN_ENABLE_METRICS","value":"1"},{"name":"KUBEWARDEN_LOG_FMT","value":"otlp"},{"name":"KUBEWARDEN_LOG_LEVEL","value":"info"}],"image":"ghcr.io/kubewarden/policy-server:latest","replicas":1,"serviceAccountName":"policy-server","verificationConfig":"","insecureSources":[],"sourceAuthorities":null}}')},7485:function(e,t,a){var s={"./allow-privilege-escalation-psp.yml":"d999","./allowed-fsgroups-psp.yml":"ec5a","./allowed-proc-mount-types-psp.yml":"437c","./apparmor-psp.yml":"00d8","./capabilities-psp.yml":"3fa6","./deprecated-api-versions.yml":"8578","./environment-variable-policy.yml":"fee6","./flexvolume-drivers-psp.yml":"636e","./host-namespaces-psp.yml":"aea3","./hostpaths-psp.yml":"5adc","./ingress-policy.yml":"54b6","./pod-runtime.yml":"c2c7","./safe-annotations.yml":"cd1e","./safe-labels.yml":"351d","./seccomp-psp.yml":"4f11","./selinux-psp.yml":"a6dc","./sysctl-psp.yml":"0988","./trusted-repos.yml":"c038","./user-group-psp.yml":"97d4","./verify-image-signatures.yml":"2b56","./volumemounts.yml":"b38b","./volumes-psp.yml":"086c"};function i(e){var t=o(e);return a(t)}function o(e){if(!a.o(s,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return s[e]}i.keys=function(){return Object.keys(s)},i.resolve=o,e.exports=i,i.id="7485"},"7b38":function(e,t,a){var s=a("b2bc");s.__esModule&&(s=s.default),"string"===typeof s&&(s=[[e.i,s,""]]),s.locals&&(e.exports=s.locals);var i=a("0ed3").default;i("9c223d98",s,!0,{sourceMap:!1,shadowMode:!1})},"7cb8":function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"env-variable-secrets-scanner"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/env-variable-secrets-scanner-policy:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{}}}')},"7ed5":function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"allow-privilege-escalation-psp"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/allow-privilege-escalation-psp:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{"default_allow_privilege_escalation":true}}}')},8309:function(e,t,a){var s=a("5eaa");t=s(!1),t.push([e.i,'.clearfix[data-v-43f9f5f0]:after,.clearfix[data-v-43f9f5f0]:before{content:" ";display:table}.clearfix[data-v-43f9f5f0]:after{clear:both}.list-unstyled[data-v-43f9f5f0]{margin:0;padding:0;list-style-type:none}.no-select[data-v-43f9f5f0]{-webkit-user-select:none;-moz-user-select:none;user-select:none}.no-resize[data-v-43f9f5f0]{resize:none}.hand[data-v-43f9f5f0]{cursor:pointer;cursor:hand}.fixed[data-v-43f9f5f0]{table-layout:fixed}.clip[data-v-43f9f5f0]{text-overflow:ellipsis;overflow:hidden;white-space:nowrap}.clip[data-v-43f9f5f0],.force-wrap[data-v-43f9f5f0]{word-wrap:break-word}.force-wrap[data-v-43f9f5f0]{white-space:normal}.bordered-section[data-v-43f9f5f0]{border-bottom:1px solid var(--border);margin-bottom:20px;padding-bottom:20px}.section-divider[data-v-43f9f5f0]{margin-bottom:20px;margin-top:20px}.step__values__controls[data-v-43f9f5f0]{display:flex;margin-bottom:15px}.step__values__controls[data-v-43f9f5f0]>:not(:last-of-type){margin-right:10px}.step__values__content[data-v-43f9f5f0],.step__values__controls--spacer[data-v-43f9f5f0]{flex:1}.step__values__content[data-v-43f9f5f0]  .tab-container{overflow:auto}',""]),e.exports=t},8501:function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"ingress"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/ingress:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{"requireTLS":false,"allowPorts":[],"denyPorts":[]}}}')},8578:function(e,t){const a=[{questions:[{default:null,description:"This policy detects usage of Kubernetes resources that have been deprecated or removed. At deployment time, the operator must provide a Kubernetes version to use when looking for deprecation/removal objects. This is done via the kubernetes_version attribute.",group:"Settings",label:"Description",required:!1,hide_input:!0,type:"string",variable:"description"},{default:"",tooltip:"The policy will detect all the Kubernetes resources that are deprecated or removed starting from the Kubernetes version.",group:"Settings",label:"Kubernetes Version",required:!1,type:"string",variable:"kubernetes_version"},{default:!0,tooltip:"By default the policy will prevent the usage of Kubernetes resources that are already deprecated, but not yet removed. This setting will change that behavior.",group:"Settings",label:"Deny on Deprecation",required:!1,type:"boolean",variable:"deny_on_deprecation"}]}];e.exports=a.length<=1?a[0]:a},"85d3":function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"echo"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/echo:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{}}}')},8621:function(e,t,a){"use strict";a("7b38")},"866c":function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"flexvolume-drivers-psp"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/flexvolume-drivers-psp:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{"allowed_flex_volumes":[{}]}}}')},8766:function(e,t,a){"use strict";a("1dc0")},"8b88":function(e,t,a){"use strict";var s=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",[e.isCreate?a("div",{staticClass:"step__values__controls"},[a("ButtonGroup",{attrs:{options:e.YAML_OPTIONS,"inactive-class":"bg-disabled btn-sm","active-class":"bg-primary btn-sm"},model:{value:e.yamlOption,callback:function(t){e.yamlOption=t},expression:"yamlOption"}})],1):e._e(),a("div",{staticClass:"scroll__container"},[a("div",{staticClass:"scroll__content"},[e.showQuestions?[a("Tabbed",{ref:"tabs",staticClass:"step__values__content",attrs:{"side-tabs":!0},on:{changed:function(t){return e.tabChanged(t)}}},[e.valuesComponent?[a(e.valuesComponent,{tag:"component",attrs:{mode:e.mode,"custom-policy":e.customPolicy},model:{value:e.chartValues,callback:function(t){e.chartValues=t},expression:"chartValues"}})]:e._e()],2)]:e.isCreate&&!e.showQuestions?[a("YamlEditor",{ref:"yaml",staticClass:"step__values__content",attrs:{scrolling:!0,"initial-yaml-values":e.originalYamlValues,"editor-mode":e.editorMode,"hide-preview-buttons":!0},model:{value:e.currentYamlValues,callback:function(t){e.currentYamlValues=t},expression:"currentYamlValues"}})]:e._e(),a("ResourceCancelModal",{ref:"cancelModal",attrs:{"is-cancel-modal":!1,"is-form":!0},on:{"cancel-cancel":function(t){e.preYamlOption=e.yamlOption},"confirm-cancel":function(t){e.yamlOption=e.preYamlOption}}})],2)])])},i=[],o=a("da25"),r=a("907c"),n=a("c5e6"),l=a("e24b"),u=a("cc2d"),p=a("6860"),c=a("0cb2"),d=a("870a"),h=a("90cd"),f={name:"Values",props:{mode:{type:String,default:o["C"]},chartValues:{type:Object,required:!0},customPolicy:{type:Boolean,default:!1},value:{type:Object,required:!0},yamlValues:{type:String,default:""}},components:{ButtonGroup:u["a"],ResourceCancelModal:p["a"],Tabbed:c["a"],YamlEditor:d["b"]},async fetch(){var e,t,a;if(!this.chartValues.questions&&null!==(e=this.chartValues)&&void 0!==e&&null!==(t=e.policy)&&void 0!==t&&null!==(a=t.spec)&&void 0!==a&&a.settings)try{const e=await this.value.policyQuestions();Object(l["i"])(this.chartValues,"questions",e)}catch(s){console.warn("Unable to fetch chart questions: "+s)}try{this.version=this.$store.getters["catalog/version"]({repoType:"cluster",repoName:"kubewarden",chartName:"kubewarden-controller"}),await this.loadValuesComponent()}catch(s){console.warn("Unable to fetch Version: "+s)}this.generateYaml()},data(){return{YAML_OPTIONS:h["l"],currentYamlValues:"",originalYamlValues:"",showQuestions:!0,valuesComponent:null,preYamlOption:h["k"].FORM,yamlOption:h["k"].FORM}},watch:{yamlOption(e,t){switch(e){case h["k"].FORM:this.showQuestions=!0,this.$emit("editor",e);break;case h["k"].YAML:t===h["k"].FORM&&(this.currentYamlValues=Object(n["c"])(this.chartValues.policy)),this.showQuestions=!1,this.$emit("editor",e);break}}},computed:{editorMode(){return d["a"].EDIT_CODE},isCreate(){return this.mode===o["u"]}},methods:{generateYaml(){var e,t;const a=this.$store.getters["currentStore"](this.value),s=this.$store.getters[a+"/all"](r["y"]),i=null!==(e=this.chartValues)&&void 0!==e&&e.policy?Object(l["e"])(this.chartValues.policy):this.value;var o;null!==(t=this.yamlValues)&&void 0!==t&&t.length?this.currentYamlValues=this.yamlValues:this.currentYamlValues=Object(n["b"])(s,null===(o=this.value)||void 0===o?void 0:o.type,i)},async loadValuesComponent(){var e,t;null!==(e=this.value)&&void 0!==e&&e.haveComponent("kubewarden/admission")&&(this.valuesComponent=null===(t=this.value)||void 0===t?void 0:t.importComponent("kubewarden/admission"),await this.valuesComponent())},tabChanged(){window.scrollTop=0}}},m=f,b=(a("fa17"),a("d802")),g=Object(b["a"])(m,s,i,!1,null,"43f9f5f0",null);t["a"]=g.exports},"8cfd":function(e,t,a){var s=a("5eaa");t=s(!1),t.push([e.i,'.clearfix[data-v-7a52092d]:after,.clearfix[data-v-7a52092d]:before{content:" ";display:table}.clearfix[data-v-7a52092d]:after{clear:both}.list-unstyled[data-v-7a52092d]{margin:0;padding:0;list-style-type:none}.no-select[data-v-7a52092d]{-webkit-user-select:none;-moz-user-select:none;user-select:none}.no-resize[data-v-7a52092d]{resize:none}.hand[data-v-7a52092d]{cursor:pointer;cursor:hand}.fixed[data-v-7a52092d]{table-layout:fixed}.clip[data-v-7a52092d]{text-overflow:ellipsis;overflow:hidden;white-space:nowrap}.clip[data-v-7a52092d],.force-wrap[data-v-7a52092d]{word-wrap:break-word}.force-wrap[data-v-7a52092d]{white-space:normal}.bordered-section[data-v-7a52092d]{border-bottom:1px solid var(--border);margin-bottom:20px;padding-bottom:20px}.section-divider[data-v-7a52092d]{margin-bottom:20px;margin-top:20px}.step__policies[data-v-7a52092d]{display:flex;flex-direction:column;flex:1;overflow-x:hidden}.step__policies .spacer[data-v-7a52092d]{line-height:2}.filter[data-v-7a52092d]{display:flex;flex-direction:row;justify-content:flex-end;align-self:flex-end}.filter>*[data-v-7a52092d]{margin:10px}.filter[data-v-7a52092d]>:first-child{margin-left:0}.filter[data-v-7a52092d]>:last-child{margin-right:0}.filter__category[data-v-7a52092d]{min-width:200px;height:unset}@media only screen and (min-width:480px){.filter[data-v-7a52092d]{width:100%}}@media only screen and (min-width:1281px){.filter[data-v-7a52092d]{width:75%}}.grid[data-v-7a52092d]{display:flex;justify-content:flex-start;flex-wrap:wrap;margin:0 -10px}@media only screen and (min-width:480px){.grid .subtype[data-v-7a52092d]{width:100%}}@media only screen and (min-width:768px){.grid .subtype[data-v-7a52092d]{width:calc(50% - 20px)}}@media only screen and (min-width:992px){.grid .subtype[data-v-7a52092d]{width:calc(33.33333% - 20px)}}@media only screen and (min-width:1281px){.grid .subtype[data-v-7a52092d]{width:calc(25% - 20px)}}.grid .disabled[data-v-7a52092d]{opacity:.5;cursor:not-allowed}.subtype__badge[data-v-7a52092d]{background-color:var(--darker);padding:4px 5px}.subtype__aware[data-v-7a52092d],.subtype__mutation[data-v-7a52092d],.subtype__signed[data-v-7a52092d]{position:absolute;bottom:5px;padding:0 5px;border:1px solid var(--border)}.subtype__signed[data-v-7a52092d]{left:10px}.subtype__mutation[data-v-7a52092d]{right:10px}.subtype__aware[data-v-7a52092d]{right:30px}',""]),e.exports=t},9391:function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"allowed-proc-mount-types-psp"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/allowed-proc-mount-types-psp:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{"allow_unmasked_proc_mount_type":false}}}')},9450:function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"","namespace":""},"spec":{"policyServer":"","module":"","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{}}}')},"94f8":function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"trusted-repos"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/trusted-repos:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{"registries":{"allow":[""],"reject":[""]},"tags":{"reject":[""]},"images":{"allow":[""],"reject":[""]}}}}')},"94fa":function(e,t,a){var s=a("8cfd");s.__esModule&&(s=s.default),"string"===typeof s&&(s=[[e.i,s,""]]),s.locals&&(e.exports=s.locals);var i=a("0ed3").default;i("3cd7394b",s,!0,{sourceMap:!1,shadowMode:!1})},"97d4":function(e,t){const a=[{questions:[{default:null,description:"This policy is a replacement for the Kubernetes Pod Security Policy that controls containers user and groups.",group:"Settings",label:"Description",required:!1,hide_input:!0,type:"string",variable:"description"},{default:[],description:"Controls which user ID the containers are run with.",group:"Settings",label:"Run as user",hide_input:!0,type:"map[",variable:"run_as_user",subquestions:[{default:"",tooltip:"Defines the strategy used by the policy to enforce users and groups used in containers.",group:"Settings",label:"Rule",options:["MustRunAs","MustRunAsNonRoot","RunAsAny"],type:"enum",variable:"run_as_user.rule"},{default:!1,group:"Settings",label:"Overwrite",show_if:"run_as_user.rule=MustRunAs||run_as_user.rule=MustRunAsNonRoot",title:"Overwrite",tooltip:"The overwrite attribute can be set only with the MustRunAs rule. This flag configures the policy to mutate the runAsUser or runAsGroup despite of the value present in the request - even if the value is a valid one. The default value of this attribute is false.",type:"boolean",variable:"run_as_user.overwrite"},{default:[],description:"Ranges is a list of JSON objects with two attributes: min and max. Each range object define the user/group ID range used by the rule.",group:"Settings",label:"Ranges",show_if:"run_as_user.rule=MustRunAs||run_as_user.rule=MustRunAsNonRoot",hide_input:!0,type:"map[",variable:"run_as_user.ranges",subquestions:[{default:0,group:"Settings",label:"min",show_if:"run_as_user.rule=MustRunAs||run_as_user.rule=MustRunAsNonRoot",tooltip:"Minimum UID or GID",type:"int",variable:"run_as_user.ranges.min"},{default:0,group:"Settings",label:"max",show_if:"run_as_user.rule=MustRunAs||run_as_user.rule=MustRunAsNonRoot",tooltip:"Maxium UID or GID",type:"int",variable:"run_as_user.ranges.max"}]}]},{default:[],description:"Controls which primary group ID the containers are run with.",group:"Settings",label:"Run as group",hide_input:!0,type:"map[",variable:"run_as_group",subquestions:[{default:"",tooltip:"Defines the strategy used by the policy to enforce users and groups used in containers.",group:"Settings",label:"Rule",options:["MustRunAs","MustRunAsNonRoot","RunAsAny"],type:"enum",variable:"run_as_group.rule"},{default:!1,group:"Settings",label:"Overwrite",show_if:"run_as_group.rule=MustRunAs||run_as_group.rule=MustRunAsNonRoot",type:"boolean",variable:"run_as_group.overwrite"},{default:[],description:"Ranges is a list of JSON objects with two attributes: min and max. Each range object define the user/group ID range used by the rule.",group:"Settings",label:"Ranges",show_if:"run_as_group.rule=MustRunAs||run_as_group.rule=MustRunAsNonRoot",hide_input:!0,type:"map[",variable:"run_as_group.ranges",subquestions:[{default:0,group:"Settings",label:"min",show_if:"run_as_group.rule=MustRunAs||run_as_group.rule=MustRunAsNonRoot",tooltip:"Minimum UID or GID",type:"int",variable:"run_as_group.ranges.min"},{default:0,group:"Settings",label:"max",show_if:"run_as_group.rule=MustRunAs||run_as_group.rule=MustRunAsNonRoot",tooltip:"Maxium UID or GID",type:"int",variable:"run_as_group.ranges.max"}]}]},{default:[],description:"Controls which group IDs containers add.",group:"Settings",label:"Supplemental groups",hide_input:!0,type:"map[",variable:"supplemental_groups",subquestions:[{default:"",tooltip:"Defines the strategy used by the policy to enforce users and groups used in containers.",group:"Settings",label:"Rule",options:["MustRunAs","MustRunAsNonRoot","RunAsAny"],type:"enum",variable:"supplemental_groups.rule"},{default:!1,group:"Settings",label:"Overwrite",show_if:"supplemental_groups.rule=MustRunAs||supplemental_groups.rule=MustRunAsNonRoot",type:"boolean",variable:"supplemental_groups.overwrite"},{default:[],description:"Ranges is a list of JSON objects with two attributes: min and max. Each range object define the user/group ID range used by the rule.",group:"Settings",label:"Ranges",show_if:"supplemental_groups.rule=MustRunAs||supplemental_groups.rule=MustRunAsNonRoot",hide_input:!0,type:"map[",variable:"supplemental_groups.ranges",subquestions:[{default:0,group:"Settings",label:"min",show_if:"supplemental_groups.rule=MustRunAs||supplemental_groups.rule=MustRunAsNonRoot",tooltip:"Minimum UID or GID",type:"int",variable:"supplemental_groups.ranges.min"},{default:0,group:"Settings",label:"max",show_if:"supplemental_groups.rule=MustRunAs||supplemental_groups.rule=MustRunAsNonRoot",tooltip:"Maxium UID or GID",type:"int",variable:"supplemental_groups.ranges.max"}]}]}]}];e.exports=a.length<=1?a[0]:a},a6dc:function(e,t){const a=[{questions:[{default:null,description:"This policy is a replacement for the Kubernetes Pod Security Policy that controls the usage of SELinux in the pod security context and on containers, init containers and ephemeral containers. This policy will inspect the `.spec.securityContext.seLinuxOptions` of the pod  if the container has no specific `.spec.securityContext.seLinuxOptions`. In other words, the `seLinuxOptions` of the container, init container and ephemeral containers take precendence over the pod `seLinuxOptions`, if any.",group:"Settings",label:"Description",required:!1,hide_input:!0,type:"string",variable:"description"},{default:"MustRunAs",tooltip:"Defines what seLinuxOptions can be set at the pod level and at the container level.",group:"Settings",label:"SE Linux Options",options:["MustRunAs","RunAsAny"],required:!1,type:"enum",variable:"rule"},{default:[],description:"Contains the desired value for the `seLinuxOptions` parameter. If the pod does not contain a `.securityContext`, or a `.securityContext.seLinuxOptions`, then this policy acts as mutating and defaults the `seLinuxOptions` attribute to the one provided in the configuration. In all cases, pod containers, init container and ephemeral containers `.seLinuxOptions` are checked for compatibility if they override the Pod Security Context `seLinuxOptions` value.",group:"Settings",label:"Must run as",show_if:"rule=MustRunAs",hide_input:!0,type:"map[",variable:"MustRunAs",subquestions:[{default:"",group:"Settings",label:"User",show_if:"rule=MustRunAs",type:"string",variable:"MustRunAs.user"},{default:"",group:"Settings",label:"Role",show_if:"rule=MustRunAs",type:"string",variable:"MustRunAs.role"},{default:"",group:"Settings",label:"Type",show_if:"rule=MustRunAs",type:"string",variable:"MustRunAs.type"},{default:0,group:"Settings",label:"Level",show_if:"rule=MustRunAs",type:"int",variable:"MustRunAs.level"}]},{default:!1,tooltip:"Always accepts the request.",group:"Settings",show_if:"rule=RunAsAny",title:"Run as any",type:"boolean",variable:"RunAsAny"}]}];e.exports=a.length<=1?a[0]:a},a735:function(e,t,a){"use strict";a("94fa")},a779:function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"pod-runtime"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/pod-runtime:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{"reservedRuntimes":[""],"fallbackRuntime":"","defaultRuntimeReserved":true}}}')},aa16:function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"deprecated-api-versions"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/deprecated-api-versions:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{"kubernetes_version":"","deny_on_deprecation":true}}}')},ad18:function(e,t,a){"use strict";var s=function(){var e=this,t=e.$createElement,a=e._self._c||t;return e.$fetchState.pending?a("Loading",{attrs:{mode:"relative"}}):a("div",[e.value?a("Wizard",{ref:"wizard",staticClass:"wizard",attrs:{errors:e.errors,steps:e.steps,"edit-first-step":!0,"banner-title":e.splitType,"banner-title-subtext":e.typeModule},on:{next:e.reset,cancel:e.done,finish:e.finish},scopedSlots:e._u([{key:"policies",fn:function(){return[a("PolicyGrid",{attrs:{value:e.packages},on:{selectType:function(t){return e.selectType(t)}},scopedSlots:e._u([e.hasArtifactHub?null:{key:"whitelistBanner",fn:function(){return[a("Banner",{staticClass:"type-banner mb-20 mt-0",attrs:{color:"warning"}},[a("div",[a("p",{staticClass:"mb-10"},[e._v(" "+e._s(e.t("kubewarden.policies.noArtifactHub"))+" ")]),a("AsyncButton",{attrs:{mode:"artifactHub"},on:{click:e.addArtifactHub}})],1)])]},proxy:!0},{key:"customSubtype",fn:function(){return[a("div",{staticClass:"subtype",on:{click:function(t){return e.selectType("custom")}}},[a("div",{staticClass:"subtype__metadata"},[a("div",{staticClass:"subtype__badge",style:{"background-color":"var(--darker)"}},[a("label",[e._v(e._s(e.t("kubewarden.customPolicy.badge")))])]),a("h4",{staticClass:"subtype__label"},[e._v(" "+e._s(e.t("kubewarden.customPolicy.title"))+" ")]),a("div",{staticClass:"subtype__description"},[e._v(" "+e._s(e.t("kubewarden.customPolicy.description"))+" ")])])])]},proxy:!0}],null,!0)})]},proxy:!0},{key:"readme",fn:function(){return[e.packageValues?a("ChartReadme",{staticClass:"mb-20",attrs:{"version-info":e.packageValues}}):e._e()]},proxy:!0},{key:"values",fn:function(){return[a("Values",{attrs:{value:e.value,"chart-values":e.chartValues,"yaml-values":e.yamlValues,mode:e.mode,"custom-policy":e.customPolicy},on:{editor:function(t){return e.yamlOption=t}}})]},proxy:!0},{key:"finish",fn:function(){return[a("AsyncButton",{attrs:{disabled:!e.canFinish,mode:"finish"},on:{click:e.finish}})]},proxy:!0}],null,!1,3558830955),model:{value:e.value,callback:function(t){e.value=t},expression:"value"}}):e._e()],1)},i=[],o=a("7838"),r=a.n(o),n=a("1fcb"),l=a.n(n),u=a("330a"),p=a.n(u),c=a("9e74"),d=a.n(c),h=a("42b0"),f=a("305c"),m=a("da25"),b=a("c5e6"),g=a("e24b"),v=a("6418"),y=a("d709"),w=a("15ca"),_=a("7202"),x=a("ed59"),S=a("465c"),k=a("90cd"),V=a("9450"),A=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("form",{staticClass:"create-resource-container step__policies"},[e._t("whitelistBanner"),a("div",{staticClass:"filter"},[a("LabeledSelect",{staticClass:"filter__keywords",attrs:{clearable:!0,taggable:!0,mode:e.mode,multiple:!0,label:"Filter by Keyword",options:e.keywordOptions},model:{value:e.keywords,callback:function(t){e.keywords=t},expression:"keywords"}}),a("LabeledSelect",{staticClass:"filter__category",attrs:{clearable:!0,searchable:!1,options:e.resourceOptions,mode:e.mode,multiple:!0,placement:"bottom",label:"Filter by Resource Type"},model:{value:e.category,callback:function(t){e.category=t},expression:"category"}}),a("input",{directives:[{name:"model",rawName:"v-model",value:e.searchQuery,expression:"searchQuery"}],ref:"searchQuery",staticClass:"input-sm filter__search",attrs:{type:"search",placeholder:e.t("catalog.charts.search")},domProps:{value:e.searchQuery},on:{input:function(t){t.target.composing||(e.searchQuery=t.target.value)}}}),a("button",{ref:"btn",staticClass:"btn, btn-sm, role-primary",attrs:{type:"button"},on:{click:e.refresh}},[e._v(" "+e._s(e.t("kubewarden.utils.resetFilter"))+" ")])],1),a("div",{staticClass:"grid"},[e._t("customSubtype"),e._l(e.filteredSubtypes,(function(t){return a("div",{key:t.package_id,staticClass:"subtype",on:{click:function(a){return e.$emit("selectType",t.name)}}},[a("div",{staticClass:"subtype__metadata"},[a("div",{staticClass:"subtype__badge"},[a("label",[e._v(e._s(e.resourceType(t.data["kubewarden/resources"])))])]),t.signed?a("div",{staticClass:"subtype__signed"},[a("i",{directives:[{name:"tooltip",rawName:"v-tooltip",value:e.t("kubewarden.policyCharts.signedPolicy"),expression:"t('kubewarden.policyCharts.signedPolicy')"}],staticClass:"icon icon-checkmark"})]):e._e(),"true"===t.data["kubewarden/mutation"]?a("div",{staticClass:"subtype__mutation"},[a("i",{directives:[{name:"tooltip",rawName:"v-tooltip",value:e.t("kubewarden.policyCharts.mutationPolicy"),expression:"t('kubewarden.policyCharts.mutationPolicy')"}],staticClass:"icon icon-edit"})]):e._e(),"true"===t.data["kubewarden/contextAware"]?a("div",{staticClass:"subtype__aware"},[a("i",{directives:[{name:"tooltip",rawName:"v-tooltip",value:e.t("kubewarden.policyCharts.contextAware"),expression:"t('kubewarden.policyCharts.contextAware')"}],staticClass:"icon icon-show"})]):e._e(),a("h4",{staticClass:"subtype__label"},[e._v(" "+e._s(t.display_name)+" ")]),t.description?a("div",{staticClass:"subtype__description mb-20"},[e._v(" "+e._s(t.description)+" ")]):e._e()])])}))],2)],2)},R=[],C=a("2cb5"),O=a("1d19"),q=a("466b"),M={props:{mode:{type:String,default:m["u"]},value:{type:Array,default:()=>[]}},components:{LabeledSelect:q["a"]},fetch(){const e=this.$route.query;this.category=e[m["b"]]||"",this.searchQuery=e[m["n"]]||""},data(){return{category:null,keywords:[],searchQuery:null}},computed:{filteredSubtypes(){const e=this.value||[],t=e.filter(e=>{var t,a;if(this.category&&(null===(t=e.data)||void 0===t||null===(a=t["kubewarden/resources"])||void 0===a||!a.includes(this.category)))return!1;if(this.searchQuery){const t=this.searchQuery.split(/\s*[, ]\s*/).map(e=>Object(C["e"])(e,!1));for(const a of t){var s;if((null===(s=e.label)||void 0===s||!s.match(a))&&e.description&&!e.description.match(a))return!1}}if(this.keywords)for(const i of this.keywords)if(!e.keywords.includes(i))return!1;return!0});return Object(O["a"])(t,["category","label","description"])},keywordOptions(){var e;const t=null===(e=this.value)||void 0===e?void 0:e.flatMap(e=>e.keywords).sort();return[...new Set(t)]||!1},resourceOptions(){var e;const t=[],a=null===(e=this.value)||void 0===e?void 0:e.flatMap(e=>{var t;return null===(t=e.data)||void 0===t?void 0:t["kubewarden/resources"]});return null===a||void 0===a||a.flatMap(e=>{const a=e.split(",");a.length>1?a.forEach(e=>t.push(e)):t.push(e)}).sort(),[...new Set(t)]||!1}},methods:{refresh(){this.category=null,this.keywords=[],this.searchQuery=null},resourceType(e){const t=e.split(",");return t.length>1?"Multiple":"*"===e?"Global":e}}},j=M,P=(a("a735"),a("d802")),T=Object(P["a"])(j,A,R,!1,null,"7a52092d",null),N=T.exports,D=a("8b88"),I={name:"Create",components:{AsyncButton:y["b"],Banner:v["a"],Loading:w["a"],ChartReadme:_["a"],Wizard:x["a"],PolicyGrid:N,Values:D["a"]},props:{mode:{type:String,default:m["u"]},value:{type:Object,default:()=>({})}},mixins:[h["a"],f["a"]],async fetch(){var e,t,s,i,o,n,l;if(this.errors=[],this.hasArtifactHub&&await this.getPackages(),!this.chartValues)try{this.questions=(await a.e(28).then(a.t.bind(null,"6402",7))).default;const e=r.a.load(JSON.stringify(this.questions));this.chartValues={questions:e}}catch(u){console.warn("Error importing questions "+u)}null!==(e=this.chartValues)&&void 0!==e&&e.policy?this.yamlValues=Object(b["c"])(this.chartValues.policy):(this.yamlValues=Object(b["c"])(V),this.$set(this.chartValues,"policy",{})),this.value.apiVersion=`${null===(t=this.schema)||void 0===t||null===(s=t.attributes)||void 0===s?void 0:s.group}.${null===(i=this.schema)||void 0===i||null===(o=i.attributes)||void 0===o?void 0:o.version}`,this.value.kind=null===(n=this.schema)||void 0===n||null===(l=n.attributes)||void 0===l?void 0:l.kind},data(){return{errors:null,packages:null,questions:null,repository:null,splitType:null,type:null,typeModule:null,version:null,chartValues:null,yamlValues:"",hasCustomPolicy:!1,yamlOption:k["k"].FORM,stepPolicies:{hidden:!1,name:"policies",label:"Policies",ready:!1,weight:99},stepReadme:{hidden:!1,name:"readme",label:"Readme",ready:!0,weight:98},stepValues:{name:"values",label:"Values",ready:!0,weight:97}}},computed:{isCreate(){return this.realMode===m["u"]},isSelected(){return!!this.type},customPolicy(){return"custom"===this.type},canFinish(){var e,t,a;return this.yamlOption===k["k"].YAML||!(null===(e=this.chartValues)||void 0===e||null===(t=e.policy)||void 0===t||null===(a=t.spec)||void 0===a||!a.module)&&this.hasRequiredRules},hasArtifactHub(){if(this.whitelistSetting){const e=this.whitelistSetting.value.split(","),t=e.includes("artifacthub.io");return t&&this.getPackages(),t}return!1},hasRequiredRules(){var e,t;const{rules:a}=null===(e=this.chartValues)||void 0===e||null===(t=e.policy)||void 0===t?void 0:t.spec,s=["apiGroups","apiVersions","operations","resources"],i=null===a||void 0===a?void 0:a.find(e=>{const t=[];for(const a of s.values())p()(e[a])||t.push(a);return d()(t,s)?e:null});return!p()(i)},packageValues(){if(this.type){var e;const t=null===(e=this.packages)||void 0===e?void 0:e.find(e=>e.name===this.type);return t}return null},steps(){const e=[];return e.push(this.stepPolicies,this.stepReadme,this.stepValues),e.sort((e,t)=>t.weight-e.weight)},whitelistSetting(){return this.value.whitelistSetting}},methods:{async addArtifactHub(e){try{await this.value.updateWhitelist("artifacthub.io"),e(!0)}catch(t){this.errors=t,e(!1)}},done(){var e;this.$router.replace({name:"c-cluster-product-resource",params:{cluster:this.$route.params.cluster,product:k["g"],resource:null===(e=this.schema)||void 0===e?void 0:e.id}})},async finish(e){try{let a;const{ignoreRancherNamespaces:s}=this.chartValues.policy;var t;if(s&&(Object(g["i"])(this.chartValues.policy.spec,"namespaceSelector",{matchExpressions:[S["b"]]}),delete this.chartValues.policy.ignoreRancherNamespaces),this.yamlOption===k["k"].YAML)a=r.a.load(this.yamlValues);else a=null!==(t=this.chartValues)&&void 0!==t&&t.policy?this.chartValues.policy:r.a.load(this.yamlValues);l()(this.value,a),await this.save(e)}catch(a){this.errors.push(a)}},async getPackages(){if(this.repository=await this.value.artifactHubRepo(),this.repository&&this.repository.packages.length>0){const t=this.repository.packages.map(e=>this.packageDetails(e));try{this.packages=await Promise.all(t)}catch(e){console.warn("Error fetching packages: "+e)}}},async packageDetails(e){try{return await this.value.artifactHubPackage(e)}catch(t){}},policyQuestions(){var e,t,s;const i=null===(e=this.type)||void 0===e?void 0:e.replace(k["e"].SPOOFED.POLICIES+".","");let o,n;try{o="custom"!==i?a("360f")(`./${i}.json`):V}catch(l){console.warn(`Unable to match policy chart ${i}, falling back to default`)}if(Object(g["i"])(this.chartValues,"policy",o),null!==(t=o)&&void 0!==t&&null!==(s=t.spec)&&void 0!==s&&s.settings&&!p()(o.spec.settings)){try{n=a("7485")(`./${i}.yml`)}catch(l){console.warn("Error when matching policy questions")}if(n){const e=r.a.load(JSON.stringify(n));Object(g["i"])(this.chartValues,"questions",e)}}},reset(e){this.$nextTick(()=>{var t;if((null===(t=e.step)||void 0===t?void 0:t.name)===this.stepPolicies.name){var a,s;const e=["errors","splitType","type","typeModule","version","chartValues.policy","hasCustomPolicy"];e.forEach(e=>{this[e]=null}),this.stepPolicies.ready=!1,this.stepReadme.hidden=!1,null!==(a=this.chartValues)&&void 0!==a&&null!==(s=a.questions)&&void 0!==s&&s.questions&&(this.chartValues.questions.questions=[]),this.yamlOption=k["k"].FORM,this.yamlValues=""}})},selectType(e){var t,a;this.type=e;const s="custom"===e;s?(this.stepReadme.hidden=!0,this.$set(this,"hasCustomPolicy",!0)):(this.packageValues?this.stepReadme.hidden=!1:this.stepReadme.hidden=!0,this.$set(this,"hasCustomPolicy",!1)),this.$router.push({query:{[m["l"]]:k["g"],[m["m"]]:"cluster",[m["c"]]:s?"custom":e.replace(k["e"].SPOOFED.POLICIES+".","")}}),this.policyQuestions(),this.stepPolicies.ready=!0,this.$refs.wizard.next(),this.splitType=e.split("policies.kubewarden.io.policies.")[1],this.typeModule=null===(t=this.chartValues)||void 0===t||null===(a=t.policy)||void 0===a?void 0:a.spec.module}}},E=I,L=(a("8621"),Object(P["a"])(E,s,i,!1,null,"3ea24628",null));t["a"]=L.exports},aea3:function(e,t){const a=[{questions:[{default:null,description:"This policy works by defining what host namespaces can be used by a Pod. `allow_host_ipc`, `allow_host_network` and `allow_host_pid` are `false` by default. `allow_host_ports` is an empty list by default. This means that by default host IPC, network, pid and all host ports are disabled when this policy is loaded with no configuration.",group:"Settings",label:"Description",required:!1,hide_input:!0,type:"string",variable:"description"},{default:!1,tooltip:"Allows the pod to set .spec.HostIPC to true.",group:"Settings",label:"Allow host IPC",required:!1,type:"boolean",variable:"allow_host_ipc"},{default:!1,tooltip:"Allows the pod to set .spec.HostNetwork to true.",group:"Settings",label:"Allow host network",required:!1,type:"boolean",variable:"allow_host_network"},{default:!1,tooltip:"Allows the pod to set .spec.HostPID to true.",group:"Settings",label:"Allow host PID",required:!1,type:"boolean",variable:"allow_host_pid"},{default:[],description:"A range of ports to allow, an example would allow host ports `80`, `443` and the range `8000-9000`.",group:"Settings",label:"Allow host ports",hide_input:!0,type:"map[",variable:"allow_host_ports",subquestions:[{default:0,tooltip:"",group:"Settings",label:"min",type:"int",variable:"allow_host_ports.min"},{default:0,tooltip:"",group:"Settings",label:"max",type:"int",variable:"allow_host_ports.max"}]}]}];e.exports=a.length<=1?a[0]:a},b063:function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"readonly-root-filesystem-psp"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/readonly-root-filesystem-psp:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{}}}')},b275:function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"seccomp-psp"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/seccomp-psp:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{"allowed_profiles":[""],"profile_types":[""],"localhost_profiles":[""]}}}')},b2bc:function(e,t,a){var s=a("5eaa");t=s(!1),t.push([e.i,'.clearfix[data-v-3ea24628]:after,.clearfix[data-v-3ea24628]:before{content:" ";display:table}.clearfix[data-v-3ea24628]:after{clear:both}.list-unstyled[data-v-3ea24628]{margin:0;padding:0;list-style-type:none}.no-select[data-v-3ea24628]{-webkit-user-select:none;-moz-user-select:none;user-select:none}.no-resize[data-v-3ea24628]{resize:none}.hand[data-v-3ea24628]{cursor:pointer;cursor:hand}.fixed[data-v-3ea24628]{table-layout:fixed}.clip[data-v-3ea24628]{text-overflow:ellipsis;overflow:hidden;white-space:nowrap}.clip[data-v-3ea24628],.force-wrap[data-v-3ea24628]{word-wrap:break-word}.force-wrap[data-v-3ea24628]{white-space:normal}.bordered-section[data-v-3ea24628]{border-bottom:1px solid var(--border);margin-bottom:20px;padding-bottom:20px}.section-divider[data-v-3ea24628]{margin-bottom:20px;margin-top:20px}[data-v-3ea24628] .step-container{height:auto}[data-v-3ea24628] .header .step-sequence .steps .divider{top:22px}[data-v-3ea24628] .controls-row .controls-steps{display:flex}[data-v-3ea24628] .subtype{height:110px;margin:10px;position:relative;border-radius:calc(var(--border-radius)*1.5);border:1px solid var(--border);text-decoration:none!important;color:var(--body-text)!important}[data-v-3ea24628] .subtype:hover:not(.disabled){box-shadow:0 0 30px var(--shadow);transition:box-shadow .1s ease-in-out;cursor:pointer;text-decoration:none!important}[data-v-3ea24628] .subtype__metadata{padding:10px}[data-v-3ea24628] .subtype__metadata__description,[data-v-3ea24628] .subtype__metadata__label{padding-right:20px}[data-v-3ea24628] .subtype__badge{position:absolute;right:0;top:0;padding:4px 5px;border-bottom-left-radius:var(--border-radius)}[data-v-3ea24628] .subtype__badge label{font-size:12px;line-height:12px;text-align:center;display:block;white-space:no-wrap;text-overflow:ellipsis;color:var(--app-rancher-accent-text);margin:0}[data-v-3ea24628] .subtype__label{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;margin-bottom:4px;line-height:normal}[data-v-3ea24628] .subtype__description{margin-right:10px;display:-webkit-box;-webkit-box-orient:vertical;-webkit-line-clamp:3;line-clamp:3;overflow:hidden;text-overflow:ellipsis;color:var(--input-label)}',""]),e.exports=t},b38b:function(e,t){const a=[{questions:[{default:null,description:"This policy inspects containers, init containers, or ephemeral containers, and will restrict their usage of volumes by checking the volume name being used in volumeMounts[*].name. The policy can target either Pods or workload resources (Deployments, ReplicaSets, DaemonSets, ReplicationControllers, Jobs, CronJobs) by setting the policy's spec.rules accordingly.",group:"Settings",label:"Description",required:!1,hide_input:!0,type:"string",variable:"description"},{default:"anyIn",group:"Settings",label:"Reject",options:["anyIn","anyNotIn","allAreUsed","notAllAreUsed"],required:!1,type:"enum",variable:"reject"},{default:[],description:"A list of Volume Mount names to match using the defined reject operator.",group:"Settings",label:"Volume Mount Names",required:!1,type:"array[",variable:"volumeMountsNames"}]}];e.exports=a.length<=1?a[0]:a},bb31:function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"allowed-fsgroups-psp"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/allowed-fsgroups-psp:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{"rule":"","ranges":[{"min":1000,"max":2000}]}}}')},be44:function(e,t,a){var s={"./example.vue":"ce60","./istio.vue":"826d","./logging/index.vue":"3c69","./monitoring/ClusterSelector.vue":"9d63","./monitoring/StorageClassSelector.vue":"3e15","./monitoring/alerting/index.vue":"72af","./monitoring/grafana/index.vue":"28b8","./monitoring/index.vue":"1c3e","./monitoring/prometheus/index.vue":"0a93","./monitoring/steps/uninstall-v1.vue":"29af","./rancher-alerting-drivers.vue":"ca1f","./rancher-backup/S3.vue":"8b03","./rancher-backup/index.vue":"39f3","./rancher-gatekeeper.vue":"dd1b"};function i(e){var t=o(e);return a(t)}function o(e){if(!a.o(s,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return s[e]}i.keys=function(){return Object.keys(s)},i.resolve=o,e.exports=i,i.id="be44"},c038:function(e,t){const a=[{questions:[{default:null,description:"This policy allows you to restrict what repositories, tags, and images pods in your cluster can refer to. The configuration allows you to mix and match several filters: registries, tags, and images. When both an allow list and a reject list is supported, only one can be provided at the same time for that specific filter.",group:"Settings",label:"Description",required:!1,hide_input:!0,type:"string",variable:"description"},{default:[],description:"Allow or reject images coming from a specified registry.",group:"Settings",label:"Registries",hide_input:!0,type:"map[",variable:"registries",subquestions:[{default:[],group:"Settings",label:"Allow",type:"array[",variable:"registries.allow"},{default:[],group:"Settings",label:"Reject",type:"array[",variable:"registries.reject"}]},{default:[],description:"Reject a specified tag for all images",group:"Settings",label:"Tags",hide_input:!0,type:"map[",variable:"tags",subquestions:[{default:[],group:"Settings",label:"Reject",type:"array[",variable:"tags.reject"}]},{default:[],description:"Accept or reject a specified image",group:"Settings",label:"Images",hide_input:!0,type:"map[",variable:"images",subquestions:[{default:[],group:"Settings",label:"Allow",type:"array[",variable:"images.allow"},{default:[],group:"Settings",label:"Reject",type:"array[",variable:"images.reject"}]}]}];e.exports=a.length<=1?a[0]:a},c2c7:function(e,t){const a=[{questions:[{default:[],description:"This policy can be used to inspect `CREATE` and `UPDATE` requests of `Pod` resources, and can be configured to replace a non-valid runtime with a fall-back one.",tooltip:"Give the explicit request to use a specific runtime.",group:"Settings",label:"Reserved Runtimes",required:!1,type:"array[",variable:"reservedRuntimes"},{default:"",tooltip:"Replace a non-valid runtime with a fall-back.",group:"Settings",label:"Fallback runtime",required:!1,type:"string",variable:"fallbackRuntime"},{default:!0,tooltip:"Prevent the usage of the default runtime.",group:"Settings",label:"Default runtime reserved",required:!1,type:"boolean",variable:"defaultRuntimeReserved"}]}];e.exports=a.length<=1?a[0]:a},c44b:function(e,t,a){var s=a("5eaa");t=s(!1),t.push([e.i,'.clearfix[data-v-56b7c1bc]:after,.clearfix[data-v-56b7c1bc]:before{content:" ";display:table}.clearfix[data-v-56b7c1bc]:after{clear:both}.list-unstyled[data-v-56b7c1bc]{margin:0;padding:0;list-style-type:none}.no-select[data-v-56b7c1bc]{-webkit-user-select:none;-moz-user-select:none;user-select:none}.no-resize[data-v-56b7c1bc]{resize:none}.hand[data-v-56b7c1bc]{cursor:pointer;cursor:hand}.fixed[data-v-56b7c1bc]{table-layout:fixed}.clip[data-v-56b7c1bc]{text-overflow:ellipsis;overflow:hidden;white-space:nowrap}.clip[data-v-56b7c1bc],.force-wrap[data-v-56b7c1bc]{word-wrap:break-word}.force-wrap[data-v-56b7c1bc]{white-space:normal}.bordered-section[data-v-56b7c1bc]{border-bottom:1px solid var(--border);margin-bottom:20px;padding-bottom:20px}.section-divider[data-v-56b7c1bc]{margin-bottom:20px;margin-top:20px}[data-v-56b7c1bc] .step-container{height:auto}.step__basic[data-v-56b7c1bc]{display:flex;flex-direction:column;flex:1;overflow-x:hidden}.step__basic .spacer[data-v-56b7c1bc]{line-height:2}.step__values__controls[data-v-56b7c1bc]{display:flex;margin-bottom:15px}.step__values__controls[data-v-56b7c1bc]>:not(:last-of-type){margin-right:10px}.step__values__content[data-v-56b7c1bc],.step__values__controls--spacer[data-v-56b7c1bc]{flex:1}.step__values__content[data-v-56b7c1bc]  .tab-container{overflow:auto}',""]),e.exports=t},c8f2:function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"environment-variable-policy"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/environment-variable-policy:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{"rules":[{"reject":"","environmentVariables":[{"name":"","value":""}]}]}}}')},c9dd:function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"sysctl-psp"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/sysctl-psp:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{"forbiddenSysctls":[""],"allowedUnsafeSysctls":[""]}}}')},cd1e:function(e,t){const a=[{questions:[{default:null,description:"This policy validates the annotations of generic Kubernetes objects. It rejects all the resources that use one or more annotations on the deny list. It also allows you to put constraints on specific annotations. The constraints are expressed as regular expression.",group:"Settings",label:"Description",required:!1,hide_input:!0,type:"string",variable:"description"},{default:[],tooltip:"A list of annotations that cannot be used",group:"Settings",label:"Denied annotations",required:!1,type:"array[",variable:"denied_annotations"},{default:[],tooltip:"Annotations that are validated with user-defined RegExp",group:"Settings",label:"Constrained annotations",target:!0,type:"map[",variable:"constrained_annotations"}]}];e.exports=a.length<=1?a[0]:a},cf89:function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"safe-annotations"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/safe-annotations:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{"denied_annotations":[""],"constrained_annotations":[{}]}}}')},d1d7:function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"volumes-psp"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/volumes-psp:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{"allowedTypes":[""]}}}')},d999:function(e,t){const a=[{questions:[{default:!0,description:"This policy works by inspecting the containers and init containers of a Pod. If any of these containers have `allowPrivilegeEscalation` enabled, the Pod will be rejected.",tooltip:"Used to default to disallow, while still permitting pods to request allowPrivilegeEscalation explicitly.",group:"Settings",label:"Allow privilege escalation",required:!1,type:"boolean",variable:"default_allow_privilege_escalation"}]}];e.exports=a.length<=1?a[0]:a},dbe7:function(e){e.exports=JSON.parse('{"apiVersion":"v2","kind":"","metadata":{"name":"host-namespaces-psp"},"spec":{"policyServer":"","module":"ghcr.io/kubewarden/policies/host-namespaces-psp:latest","rules":[{"apiGroups":[],"apiVersions":[],"resources":[],"operations":[]}],"mutating":false,"settings":{"allow_host_ipc":false,"allow_host_network":false,"allow_host_pid":false,"allow_host_ports":[{"min":0,"max":0}]}}}')},e1ff:function(e,t,a){"use strict";a.r(t);var s=function(){var e=this,t=e.$createElement,a=e._self._c||t;return e.isCreate?a("Create",{attrs:{value:e.value,mode:e.mode}}):a("CruResource",{attrs:{resource:e.value,mode:e.realMode},on:{finish:e.finish}},[a("Config",{attrs:{value:e.value,mode:e.realMode}})],1)},i=[],o=a("da25"),r=a("42b0"),n=a("305c"),l=a("fd5f"),u=a("edaa"),p=a("ad18"),c={name:"ClusterAdmissionPolicy",props:{value:{type:Object,required:!0},mode:{type:String,default:o["w"]},realMode:{type:String,default:o["w"]}},components:{CruResource:l["a"],Config:u["a"],Create:p["a"]},mixins:[r["a"],n["a"]],async fetch(){await this.fetchChart()},provide(){return{chartType:this.value.type}},computed:{isCreate(){return this.realMode===o["u"]}},methods:{async finish(e){try{await this.save(e)}catch(t){this.errors.push(t)}}}},d=c,h=a("d802"),f=Object(h["a"])(d,s,i,!1,null,null,null);t["default"]=f.exports},ec5a:function(e,t){const a=[{questions:[{default:"RunAsAny",tooltip:"Set which fsGroup is allowed in the pod security context.",description:"This policy works by defining what `fsGroup` is allowed in the pod security context. `MustRunAs` and `MayRunAs` contain a list of ranges that define valid ranges for the `fsGroup` value. `RunAsAny` always accepts the request.",group:"Settings",label:"Service Type",options:["MustRunAs","MayRunAs","RunAsAny"],required:!1,type:"enum",variable:"rule"},{default:[],tooltip:"Valid user ID (UID) ranges for the fsGroup.",group:"Settings",label:"User ID Ranges",show_if:"rule=MustRunAs||rule=MayRunAs",hide_input:!0,type:"map[",variable:"ranges",subquestions:[{default:1e3,tooltip:"Minimum UID range for fsgroup.",group:"Settings",label:"min",type:"int",variable:"ranges.min"},{default:2e3,tooltip:"Maximum UID range for fsgroup.",group:"Settings",label:"max",type:"int",variable:"ranges.max"}]}]}];e.exports=a.length<=1?a[0]:a},edaa:function(e,t,a){"use strict";var s=function(){var e=this,t=e.$createElement,a=e._self._c||t;return e.$fetchState.pending?a("Loading"):a("Values",{attrs:{value:e.value,"chart-values":e.chartValues,"yaml-values":e.yamlValues,mode:e.mode}})},i=[],o=a("da25"),r=a("c5e6"),n=a("15ca"),l=a("8b88"),u={name:"Config",props:{mode:{type:String,default:o["C"]},value:{type:Object,required:!0}},components:{Loading:n["a"],Values:l["a"]},fetch(){this.chartValues={policy:this.value,questions:null},this.yamlValues=Object(r["c"])(this.value)},data(){return{chartValues:null,yamlValues:""}}},p=u,c=a("d802"),d=Object(c["a"])(p,s,i,!1,null,null,null);t["a"]=d.exports},fa17:function(e,t,a){"use strict";a("6e4c")},fee6:function(e,t){const a=[{questions:[{default:null,description:"Each rule defined in the policy settings is composed by a reject operator and a set of the environment variables used with the operator against the environment variables from the resources. The rules are evaluated in the order that they are defined. The resource is denied in the first failed evaluated rule.",group:"Settings",label:"Description",required:!1,hide_input:!0,type:"string",variable:"description"},{default:[],group:"Settings",label:"Rules",hide_input:!0,type:"map[",variable:"rules",subquestions:[{default:"anyIn",group:"Settings",label:"Reject Operator",options:["anyIn","anyNotIn","allAreUsed","notAllAreUsed"],required:!1,type:"enum",variable:"rules.reject"},{default:[],description:"",group:"Settings",label:"Environment Variables",hide_input:!0,type:"map[",variable:"rules.environmentVariables",subquestions:[{default:"",group:"Settings",label:"Name",type:"string",variable:"rules.environmentVariables.name"},{default:"",group:"Settings",label:"Value",type:"string",variable:"rules.environmentVariables.value"}]}]}]}];e.exports=a.length<=1?a[0]:a}}]);
//# sourceMappingURL=kubewarden-0.1.13.umd.min.edit.js.map